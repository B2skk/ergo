\documentclass[]{article}
\RequirePackage{amsmath}

\usepackage{graphicx}
%\graphicspath{{./figures/}}
\usepackage{amssymb}
\usepackage{color}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\bibliographystyle{plain}

\newcommand{\knote}[1]{\textcolor{green}{A: {#1}}}
\newcommand{\dnote}[1]{\textcolor{red}{D: {#1}}}
\newcommand{\vk}[1]{\textcolor{blue}{V: {#1}}}
\newcommand{\lnote}[1]{\textcolor{cyan}{L: {#1}}}
\newcommand{\Name}{$Autolykos$}
\def\Let#1#2{\State #1 $:=$ #2}
\def\LetRnd#1#2{\State #1 $\gets$ #2}

\newcommand{\pk}{\mathsf{pk}}
\newcommand{\sk}{\mathsf{sk}}

\begin{document}
    \title{\Name: The Ergo Platform PoW Puzzle}

    \author{Ergo Developers}

    \date{\today}
    \maketitle

%    \begin{abstract}
%        This document contains the full description of \Name~-- the PoW protocol that is going to be used in Ergo platform.
%    \end{abstract}


    \section{Introduction}

    Security of Proof-of-Work blockchains relies on an assumption
    that multiple miners are trying to produce new blocks by
    participating in PoW puzzle and the network is secure as soon as the
    majority of them are honest.

    However in existing PoW networks miners unite in mining pools and
    this assumption should be reformulated: the network is secure as soon as the
    majority of pool operators are honest.
    Unfortunately in existing PoW cryptocurrencies
    regardless of the PoW algorithm, number of pools controls more then 50\% of
    computational power is small: 4 pools in Bitcoin, 2 in Ethereum, 3 in ZCash, etc.

    This problem led to the notion of non-outsourceable puzzles~\cite{miller2015nonoutsourceable,daian2017piecework}.
    These are the puzzles constructed in such a way that if a mining pool outsource the puzzle
    to miners, with non-negligible probability miner can recover pools private key and steal the reward.
    However existing solutions have have too large solution size (kilobyte is already
    on the edge of acceptability for distributed ledger) or very specific and
    can not be updated without breaking non-outsourceability. Thus the first goal of \Name is non-outsourceability.

    \dnote{add ASIC-resistance}

    \section{Ergo PoW puzzle}

    The proposed scheme requires following components:
    \begin{enumerate}
        \item Cyclic group $\mathbb{G}$ of prime order $q$ with fixed generator $g$
        and identity element $e$.
        Curve 25519 is used for this purposes.
        \item Number of elements $k=21$ required in the solution.
        \item List $R$ of numbers in $\mathbb{Z}/q\mathbb{Z}$ of size $N=2^{27}$ is generated
        using a hash function $H$.
        \item Hash function $H$ which returns the values in $\mathbb{Z}/q\mathbb{Z}$.
        It is based on Blake2b512 and is described in Alg.\ref{alg:H}.
        \item Hash function $genIndexes$ which returns a list of size $k$ with numbers in $0\dots (N-1)$.
        It is based on Blake2b512 and is described in Alg.\ref{alg:genIndexes}.
        \item Target interval parameter $b$, that is recalculated via difficulty adjustment rules.
        \item Constant message $M=(0~until~256).flatMap(Blake2b512)$ that is used to enlarge message size and .
    \end{enumerate}

    \Name is based on one list k-sum problem: miner should find
    $k$ elements from pre-defined list $R$ of size $N$, such that
    $\sum_{j \in J} r_{j} - sk = d$ is in the interval $\{-b,\dots,0,\dots,b\mod q\}$.
    In addition we require, that set of element indexes $J$ is received
    by one-way pseudo-random function $genIndexes$. This prevents miner
    from usage of efficient algorithms, that solves $k-sum$ problem, as
    soon as it might be hard (if possible at all) to find such a seed,
    that $genIndexes(seed)$ will return the desired indexes.

    Thus we assume that the only option for miner is to use the simple brute-force algorithm \ref{alg:prove} to
    create a valid block.

    \begin{algorithm}[H]
        \caption{Block mining}
        \label{alg:prove}
        \begin{algorithmic}[1]
            \State \textbf{Input}: latest block header $Hdr$, key pair $pk=g^{sk}$
            \State Generate randomly a new key pair $w=g^x$
            \Let{$m$}{$Blake2b256(Hdr.bytesWithoutPow)$}
            \While{$true$}
                \LetRnd{$nonce$}{$\mathsf{rand}$}
                \Let{$J$}{$genIndexes(m||nonce)$}
                \Let{$d$}{$(\sum_{j \in J}{H(i||M||pk||m||w)} \cdot x - sk).mod(q)$}
                \If{$d <= b$}
                \State \Return $(m,pk,w,nonce,d)$
                \EndIf
            \EndWhile
        \end{algorithmic}
    \end{algorithm}

    Note that although the mining process utilizes private keys, solution itself
    only contain public keys. Solution verification may be done by Alg. \ref{alg:verify}.

    \begin{algorithm}[H]
        \caption{Solution verification}
        \label{alg:verify}
        \begin{algorithmic}[1]
            \State \textbf{Input}: $m,pk,w,nonce,d$
            \State require $d\in\{-b,\dots,0,\dots, b\mod q\}$
            \State require $pk,w\in \mathbb{G}$ and $pk,w \ne e$
            \Let{$J$}{$genIndexes(m||nonce)$}
            \Let{$f$}{$\sum_{j \in J} H(i||M||pk||m||w)$}
            \State require $w^f - pk = g^d$
        \end{algorithmic}
    \end{algorithm}

    \section{Discussion}

    \dnote{TODO}

%    \Name{} is non-outsourcable, as soon as
%    mining is not possible without private keys\dnote{because it is the same as Shnorr signatures?}.

    %    Mining algorithm \ref{alg:prove} can be optimized, if miner will pre-calculate
%    hashes $H(i||M||pk||m||w)~\forall~i~\in~[0,N)$ and will get them from memory during seed search.
%    This strategy become profitable if elements will be used during mining for multiple times,
%    that is achieved a miner hashrate is higher than $N / k / 120 = 2^{17} H/s$, while moder GPU
%    hashrate is about $2^{30} H/s$~\cite{gpuHashrate}.
%
%    Let's assume $N=10^8$, $k=128$, $q$ size is 32 bytes and current difficulty
%    $h = q / b = 10^{15}$ (regular laptop hashrate on non-optimized Scala implementation is $10^6$).
%
%    Memory-hardness follows from the fact, that a miner should keep list of $N$
%    (which is 3.2 Gb with parameters above) elements in memory to allow fast random access to them.
%
%    Miner can try to reduce memory requirements by recalculating elements from this list on fly.
%    However if $h$ and $k$ are big enough
%    every element will be touched multiple ($h * k / N = 10^9$ in average) times.
%    Thus, every attempt to generate a solution requires to calculate $genIndexes$ hash and
%    either to get $k$ elements from memory or to recalculate them.
%    Elements recalcuation will require to calculate $2 * k = 256$ hashes $H$,
%    $2 * k = 256$ additions (mod q) and one multiplication (mod q).
%
%    Miner can also try to reduce memory requirements to, for example, 1.6 Gb
%    by keeping only the first half of the list and finding solutions
%    with elements from $0 \dots (N/2)$.
%    However the probability that all indexes are in $0 \dots N/2$ is
%    $2^{-k}=2^{-128}$ and as far as $genIndexes$
%    is the hash function, miner can only brute-force $2^{k=2^{128}}$ different $seed$ values for $genIndexes$
%    to find an appropriate index set.
%
%    Protocol is quite efficient: in addition to payload, block header should
%    contain 2 public keys of size 32 bytes, number $d$ that is at most 32 bytes
%    (but will contain a lot of leading zeros in case of small target $b$) and a nonce,
%    which size might be small enough (say, 8 bytes). Thus for about 100 additional bytes
%    will be added to the block header.

%    Difficulty $h$ adjusts to the network computational power in such a way,
%    that correct solutions appears roughly once per 2 minutes. Non-optimized Scala
%    implementation of mining process allows to check $10^{6}$ possible solutions per
%    2 minutes, so we may expect at least $h~10^{15}$ for the real network.


    \bibliography{references}

    \section*{Appendix}
    \label{appendix}

    Implementation of hash function $H$ which returns the values in $\mathbb{Z}/q\mathbb{Z}$:

    \begin{algorithm}[H]
        \caption{Numeric hash}
        \label{alg:H}
        \begin{algorithmic}[1]
            \Function{H}{$input$}
            \Let{$validRange$}{$(2^{512} / q) \cdot q$}
            \Let{$hashed$}{$Blake2b512(input)$}
            \If{$hashed < validRange$}
            \State \Return $hashed.mod(q)$
            \Else
            \State \Return $H(hashed)$
            \EndIf
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    Implementation of hash function $genIndexes$ which returns a list of size $k$ with numbers in $0\dots (N-1)$:

    \begin{algorithm}[H]
        \caption{Index generator}
        \label{alg:genIndexes}
        \begin{algorithmic}[1]
            \Function{genIndexes}{$seed$}
                \Let{$hash$}{$Blake2b512(Bytes.concat(seed))$}
                \State \Return $hash.grouped(3).take(k).map(_.mod(N))$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{document}
