\documentclass[]{article}
\RequirePackage{amsmath}

\usepackage{graphicx}
%\graphicspath{{./figures/}}
\usepackage{amssymb}
\usepackage{color}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}
\bibliographystyle{IEEEtran}

\newcommand{\knote}[1]{\textcolor{green}{A: {#1}}}
\newcommand{\dnote}[1]{\textcolor{red}{D: {#1}}}
\newcommand{\vk}[1]{\textcolor{blue}{V: {#1}}}
\newcommand{\lnote}[1]{\textcolor{cyan}{L: {#1}}}
\newcommand{\Name}{$Autolykos$}
\def\Let#1#2{\State #1 $:=$ #2}
\def\LetRnd#1#2{\State #1 $\gets$ #2}

\newcommand{\pk}{\mathsf{pk}}
\newcommand{\sk}{\mathsf{sk}}

\begin{document}
    \title{\Name: The Ergo Platform PoW Puzzle}

    \author{Alexander Chepurnoy, Vasily Kharin, Dmitry Meshkov}

    \date{\today}
    \maketitle

    %    \begin{abstract}
    %        This document contains the full description of \Name~-- the PoW protocol that is going to be used in Ergo platform.
    %    \end{abstract}


    \section{Introduction}

    Security of Proof-of-Work blockchains relies on an assumption
    that multiple miners are trying to produce new blocks by
    participating in PoW puzzle and the network is secure if the
    majority of them are honest. However, the reality become much more complicated
    then the original one-CPU-one-vote idea form the Bitcoin whitepaper\cite{nakamoto2008bitcoin}.

    The first threat to decentralization came from mining pools -- miners become to unite in mining pools,
    and regardless of the PoW algorithm number of pools that controls more then 50\% of
    computational power is usually quite small: 4 pools in Bitcoin, 2 in Ethereum, 3 in ZCash, etc.
    This problem led to the notion of non-outsourceable puzzles~\cite{miller2015nonoutsourceable,daian2017piecework}.
    These are the puzzles constructed in such a way that if a mining pool outsource the puzzle
    to miners, with non-negligible probability miner can recover pools private key and steal the reward.
    However the existing solutions have too large solution size (kilobyte is already
    on the edge of acceptability for distributed ledger) or very specific and
    can not be updated without breaking non-outsourceability.

    The second threat to cryptocurrencies decentralization is that ASIC-equipped miners are
    able to find PoW solutions orders of magnitude faster and more efficiently
    than miners equipped with the commodity hardware. In order to remedy the
    disparity between the ASICs and regular hardware, memory-bound computations
    where proposed~\cite{dwork2003memory}. In practice the most interesting are
    asymmetric memory-hard PoW - schemes that requires significantly less memory
    to verify a solution than to find it~\cite{biryukov2017equihash,ethHash}.
    \dnote{may be note, that there are ASICS for equihash and ETH is going to switch to ProgPow}

    In this paper we provide a specification of \Name{} -- PoW puzzle, that is
    going to be used in Ergo platform~\cite{ergo}. It is designed to be both
    non-outsourceable and memory-hard. In Section~\ref{puzzle} we provide a full
    specification of \Name, while in Section~\ref{discussion} we discuss it's
    properties. Several auxiliary algorithms are moved to~\nameref{appendix}.

    \section{Ergo PoW puzzle}
    \label{puzzle}

    The proposed scheme requires following components:
    \begin{enumerate}
        \item Cyclic group $\mathbb{G}$ of prime order $q$ with fixed generator $g$
        and identity element $e$.
        Curve 25519 is used for this purposes.
        \item Number of elements $k=21$ required in the solution.
        \item List $R$ of numbers in $\mathbb{Z}/q\mathbb{Z}$ of size $N=10^{8}$ is generated
        using a hash function $H$.
        \item Hash function $H$ which returns the values in $\mathbb{Z}/q\mathbb{Z}$.
        It is based on Blake2b512 and is described in Alg.\ref{alg:H}.
        \item Hash function $genIndexes$ which returns a list of size $k$ with numbers in $0\dots (N-1)$.
        It is based on Blake2b512 and is described in Alg.\ref{alg:genIndexes}.
        \item Target interval parameter $b$, that is recalculated via difficulty adjustment rules.
        \item Constant message $M=(0 until 2048).toArray.flatMap(i => Longs.toByteArray(i))$ that is used to enlarge message size and increase elements calculation time.
    \end{enumerate}

    \Name is based on one list k-sum problem: miner should find
    $k$ elements from pre-defined list $R$ of size $N$, such that
    $\sum_{j \in J} r_{j} - sk = d$ is in the interval $\{-b,\dots,0,\dots,b\mod q\}$.
    In addition we require, that set of element indexes $J$ is received
    by one-way pseudo-random function $genIndexes$. This prevents miner
    from usage of efficient algorithms, that solves $k-sum$ problem, as
    soon as it might be hard (if possible at all) to find such a seed,
    that $genIndexes(seed)$ will return the desired indexes.

    Thus we assume that the only option for miner is to use the simple brute-force algorithm~\ref{alg:prove} to
    create a valid block.

    \begin{algorithm}[H]
        \caption{Block mining}
        \label{alg:prove}
        \begin{algorithmic}[1]
            \State \textbf{Input}: latest block header $Hdr$, key pair $pk=g^{sk}$
            \State Generate randomly a new key pair $w=g^x$
            \Let{$m$}{$Blake2b256(Hdr.bytesWithoutPow)$}
            \While{$true$}
            \LetRnd{$nonce$}{$\mathsf{rand}$}
            \Let{$J$}{$genIndexes(m||nonce)$}
            \Let{$d$}{$(\sum_{j \in J}{H(i||M||pk||m||w)} \cdot x - sk).mod(q)$}
            \If{$d <= b$}
            \State \Return $(m,pk,w,nonce,d)$
            \EndIf
            \EndWhile
        \end{algorithmic}
    \end{algorithm}

    Note that although the mining process utilizes private keys, solution itself
    only contain public keys. Solution verification may be done by Alg.~\ref{alg:verify}.

    \begin{algorithm}[H]
        \caption{Solution verification}
        \label{alg:verify}
        \begin{algorithmic}[1]
            \State \textbf{Input}: $m,pk,w,nonce,d$
            \State require $d\in\{-b,\dots,0,\dots, b\mod q\}$
            \State require $pk,w\in \mathbb{G}$ and $pk,w \ne e$
            \Let{$J$}{$genIndexes(m||nonce)$}
            \Let{$f$}{$\sum_{j \in J} H(i||M||pk||m||w)$}
            \State require $w^f - pk = g^d$
        \end{algorithmic}
    \end{algorithm}

    \section{Discussion}
    \label{discussion}

    \Name{} mining~\ref{alg:prove} and verification~\ref{alg:verify} algorithms are
    the same as Schnorr signature algorithm, proving is not possible without access
    to private key $sk$. Thus solo mining remains the only option for miners,
    preventing centralization of the network in the hands of pool operators.
    \dnote{Correct description and links here}

    Mining algorithm~\ref{alg:prove} can be optimized, if miner will pre-calculate
    hashes $H(i||M||pk||m||w)~\forall~i~\in~[0,N)$ and will store them to memory.
    Every pre-calculated hash have occupy 32 bytes, so the whole list of $N$ elements
    will occupy $N \cdot 32 = 3 Gb$.
    Modern GPU hashrate is about $G = 2^{30} H/s$~\cite{gpuHashrate} and assuming
    block interval $t=120~s$ every element will be used
    $(G / N) \cdot k \cdot t = 2.7 \cdot 10^4$ times in average.\dnote{continue, discuss memory-hardness and on-fly calculation}

    \dnote{drawbacks: solution size, 2 exponentiations}

%    that is achieved a miner hashrate is higher than $N / k / 120 = 2^{17} H/s$, while

    %
    %    Let's assume $N=10^8$, $k=128$, $q$ size is 32 bytes and current difficulty
    %    $h = q / b = 10^{15}$ (regular laptop hashrate on non-optimized Scala implementation is $10^6$).
    %
    %    Memory-hardness follows from the fact, that a miner should keep list of $N$
    %    (which is 3.2 Gb with parameters above) elements in memory to allow fast random access to them.
    %
    %    Miner can try to reduce memory requirements by recalculating elements from this list on fly.
    %    However if $h$ and $k$ are big enough
    %    every element will be touched multiple ($h * k / N = 10^9$ in average) times.
    %    Thus, every attempt to generate a solution requires to calculate $genIndexes$ hash and
    %    either to get $k$ elements from memory or to recalculate them.
    %    Elements recalcuation will require to calculate $2 * k = 256$ hashes $H$,
    %    $2 * k = 256$ additions (mod q) and one multiplication (mod q).
    %
    %    Miner can also try to reduce memory requirements to, for example, 1.6 Gb
    %    by keeping only the first half of the list and finding solutions
    %    with elements from $0 \dots (N/2)$.
    %    However the probability that all indexes are in $0 \dots N/2$ is
    %    $2^{-k}=2^{-128}$ and as far as $genIndexes$
    %    is the hash function, miner can only brute-force $2^{k=2^{128}}$ different $seed$ values for $genIndexes$
    %    to find an appropriate index set.
    %
    %    Protocol is quite efficient: in addition to payload, block header should
    %    contain 2 public keys of size 32 bytes, number $d$ that is at most 32 bytes
    %    (but will contain a lot of leading zeros in case of small target $b$) and a nonce,
    %    which size might be small enough (say, 8 bytes). Thus for about 100 additional bytes
    %    will be added to the block header.

    %    Difficulty $h$ adjusts to the network computational power in such a way,
    %    that correct solutions appears roughly once per 2 minutes. Non-optimized Scala
    %    implementation of mining process allows to check $10^{6}$ possible solutions per
    %    2 minutes, so we may expect at least $h~10^{15}$ for the real network.


    \dnote{TODO}

    \bibliography{references}

    \section*{Appendix}
    \label{appendix}

    Implementation of hash function $H$ which returns the values in $\mathbb{Z}/q\mathbb{Z}$:

    \begin{algorithm}[H]
        \caption{Numeric hash}
        \label{alg:H}
        \begin{algorithmic}[1]
            \Function{H}{$input$}
            \Let{$validRange$}{$(2^{512} / q) \cdot q$}
            \Let{$hashed$}{$Blake2b512(input)$}
            \If{$hashed < validRange$}
            \State \Return $hashed.mod(q)$
            \Else
            \State \Return $H(hashed)$
            \EndIf
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

    Implementation of hash function $genIndexes$ which returns a list of size $k$ with numbers in $0\dots (N-1)$:

    \begin{algorithm}[H]
        \caption{Index generator}
        \label{alg:genIndexes}
        \begin{algorithmic}[1]
            \Function{genIndexes}{$seed$}
            \Let{$hash$}{$Blake2b512(Bytes.concat(seed))$}
            \State \Return $hash.grouped(3).take(k).map(_.mod(N))$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{document}
