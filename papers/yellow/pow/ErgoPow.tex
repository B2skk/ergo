\RequirePackage{silence}
\WarningFilter{remreset}{The remreset package}

\RequirePackage{amsmath}
\documentclass[]{article}

\usepackage{graphicx}
%\graphicspath{{./figures/}}
\usepackage{amssymb}
\usepackage{color}
\usepackage{hyperref}
\usepackage{algorithm}
\usepackage{algpseudocode}

\include{headers}


\begin{document}
    \title{\Name: The Ergo Platform PoW Puzzle}

    \author{Ergo Developers}

    \date{\today}
    \maketitle

%    \begin{abstract}
%        This document contains the full description of \Name~-- the PoW protocol that is going to be used in Ergo platform.
%    \end{abstract}


    \section{Introduction}

    Security of Proof-of-Work blockchains relies on an assumption
    that multiple miners are trying to produce new blocks by
    participating in PoW puzzle and the network is secure as soon as the
    majority of them are honest.

    However in existing PoW networks miners unite in mining pools and
    this assumption should be reformulated: the network is secure as soon as the
    majority of pool operators are honest.
    Unfortunately in existing PoW cryptocurrencies
    regardless of the PoW algorithm, number of pools controls more then 50\% of
    computational power is small: 4 pools in Bitcoin, 2 in Ethereum, 3 in ZCash, etc.

    This problem led to the notion of non-outsourceable puzzles~\cite{miller2015nonoutsourceable,daian2017piecework}.
    These are the puzzles constructed in such a way that if a mining pool outsource the puzzle
    to miners, with non-negligible probability miner can recover pools private key and steal the reward.
    However existing solutions have have too large solution size (kilobyte is already
    on the edge of acceptability for distributed ledger) or very specific and
    can not be updated without breaking non-outsourceability. Thus the first goal of \Name is non-outsourceability.

    \dnote{add ASIC-resistance}

    \section{Ergo PoW puzzle}

    \subsection{Prerequisites}
    The proposed scheme requires following components:
    \begin{enumerate}
        \item Cyclic group $\mathbb{G}$ of prime order $q$ with fixed generator $g$
        and identity element $e$. Discrete logarithm problem in $\mathbb{G}$ must be hard
        \item Hash function $H$ which returns the values in $\mathbb{Z}/q\mathbb{Z}$
        \item Hash function $genIndexes$ which returns a list of size $k$
        with numbers in $0\dots (N-1)$
        \item List $R$ of numbers in $\mathbb{Z}/q\mathbb{Z}$ of size $N$ is generated
        using a hash function $H$
        \item Number of elements $k$ required in the solution
        \item Target interval parameter $b$
    \end{enumerate}

    \subsection{PoW solving and validation}

    Ergo PoW puzzle is based on one list k-sum problem: miner should find
    $k$ elements from pre-defined list $R$ of size $N$, such that
    $\sum_{i} r_{i} - sk = d$ is in the interval $\{-b,\dots,0,\dots,b\mod q\}$.
    In addition we require, that set of element indexes $I$ is received
    by one-way pseudo-random function $genIndexes$. This prevents miner
    from usage of efficient algorithms, that solves $k-sum$ problem, as
    soon as it might be hard (if possible at all) to find such a seed,
    that $genIndexes(seed)$ will return the desired indexes.

    Thus miner will use a simple brute-force algorithm \ref{alg:prove} to
    create a valid block.

    \begin{algorithm}[H]
        \caption{Block mining}
        \label{alg:prove}
        \begin{algorithmic}[1]
            \State \textbf{Input}: latest block header $\msg$, key pair $pk=g^{sk}$
            \State Generate randomly a new key pair $w=g^x$
            \State Calculate $r_i=H(\msg||pk||w||i||0)+x\cdot H(\msg||pk||w||i||1)$ for $i\in 0\dots (N-1)$,
            \While{$true$}
                \State $nonce\leftarrow\mathsf{rand}$
                \Let{$J$}{$genIndexes(\msg||nonce)$}
                \Let{$d$}{$J.map(j => r_j).sum - sk$}
                \If{$d <= b$}
                \State \Return $(\msg,pk,w,nonce,d)$
                \EndIf
            \EndWhile
        \end{algorithmic}
    \end{algorithm}

    Note that although the mining process utilizes private keys, solution itself
    only contain private keys. This is the idea of \Name protocol that makes
    PoW puzzle non-outsourcable. Solution verification may be done by Alg. \ref{alg:verify}.

    \begin{algorithm}[H]
        \caption{Solution verification}
        \label{alg:verify}
        \begin{algorithmic}[1]
            \State \textbf{Input}: $\msg,pk,w,nonce,d$
            \State require $d\in\{-b,\dots,0,\dots, b\mod q\}$
            \State require $pk,w\in \mathbb{G}$ and $pk,w \ne e$
            \State calculate $J:=genIndexes(\msg||nonce)$
            \State require $g^{\sum_{j \in J} H(\msg||pk||w||j||0) - d}
            w^{\sum_{j \in J} H(\msg||w||pk||j||1)} = pk$
        \end{algorithmic}
    \end{algorithm}

    \section{Discussion}

    Let's assume $N=10^8$, $k=128$, $q$ size is 32 bytes and current difficulty
    $h = q / b = 10^{15}$ (regular laptop hashrate on non-optimized Scala implementation is $10^6$).

    Memory-hardness follows from the fact, that a miner should keep list of $N$
    (which is 3.2 Gb with parameters above) elements in memory to allow fast random access to them.

    Miner can try to reduce memory requirements by recalculating elements from this list on fly.
    However if $h$ and $k$ are big enough
    every element will be touched multiple ($h * k / N = 10^9$ in average) times.
    Thus, every attempt to generate a solution requires to calculate $genIndexes$ hash and
    either to get $k$ elements from memory or to recalculate them.
    Elements recalcuation will require to calculate $2 * k = 256$ hashes $H$,
    $2 * k = 256$ additions (mod q) and one multiplication (mod q).

    Miner can also try to reduce memory requirements to, for example, 1.6 Gb
    by keeping only the first half of the list and finding solutions
    with elements from $0 \dots (N/2)$.
    However the probability that all indexes are in $0 \dots N/2$ is
    $2^{-k}=2^{-128}$ and as far as $genIndexes$
    is the hash function, miner can only brute-force $2^{k=2^{128}}$ different $seed$ values for $genIndexes$
    to find an appropriate index set.

    Protocol is quite efficient: in addition to payload, block header $\msg$ should
    contain 2 public keys of size 32 bytes, number $d$ that is at most 32 bytes
    (but will contain a lot of leading zeros in case of small target $b$) and a nonce,
    which size might be small enough (say, 8 bytes). Thus for about 100 additional bytes
    will be added to the block header.

%    Difficulty $h$ adjusts to the network computational power in such a way,
%    that correct solutions appears roughly once per 2 minutes. Non-optimized Scala
%    implementation of mining process allows to check $10^{6}$ possible solutions per
%    2 minutes, so we may expect at least $h~10^{15}$ for the real network.


    \bibliography{references}

\end{document}
