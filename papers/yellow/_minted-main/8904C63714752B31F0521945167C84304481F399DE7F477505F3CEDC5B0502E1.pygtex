\begin{Verbatim}[commandchars=\\\{\}]
    \PYG{k}{if}\PYG{o}{(}\PYG{n}{History}\PYG{o}{.}\PYG{n+na}{apply}\PYG{o}{(}\PYG{n}{BlockTransactions}\PYG{o}{)} \PYG{o}{==} \PYG{n}{Success}\PYG{o}{(}\PYG{n}{ProgressInfo}\PYG{o}{))} \PYG{o}{\PYGZob{}}
      \PYG{k}{if}\PYG{o}{(!}\PYG{n}{isInitialBootstrapping}\PYG{o}{)} \PYG{n}{Broadcast} \PYG{n}{INV} \PYG{k}{for} \PYG{n}{BlockTransactions}
     \PYG{c+cm}{/*We should notify our neighbours, that now we have all the transactions}
\PYG{c+cm}{     State apply modifiers (may be empty for block in a fork chain)}
\PYG{c+cm}{     and generate ADProofs for them.}
\PYG{c+cm}{     TODO requires different interface from scorex\PYGZhy{}core,}
\PYG{c+cm}{     because it should return ADProofs}
\PYG{c+cm}{     TODO when mininal state apply Progress info,}
\PYG{c+cm}{     it may also create UTXOSnapshot}
\PYG{c+cm}{     (e.g. every 30000 blocks like in Ethereum).}
\PYG{c+cm}{     This UTXOSnapshot should be required for mining by Rollerchain*/}
     \PYG{k}{if}\PYG{o}{(}\PYG{n}{State}\PYG{o}{().}\PYG{n+na}{apply}\PYG{o}{(}\PYG{n}{ProgressInfo}\PYG{o}{)} \PYG{o}{==} \PYG{n}{Success}\PYG{o}{((}\PYG{n}{newState}\PYG{o}{,} \PYG{n}{ADProofs}\PYG{o}{)))} \PYG{o}{\PYGZob{}}
       \PYG{k}{if}\PYG{o}{(}\PYG{l+s}{\PYGZdq{}mode\PYGZdq{}}\PYG{o}{=}\PYG{l+s}{\PYGZdq{}full\PYGZdq{}} \PYG{o}{||} \PYG{l+s}{\PYGZdq{}mode\PYGZdq{}}\PYG{o}{==}\PYG{l+s}{\PYGZdq{}pruned\PYGZhy{}full\PYGZdq{}}\PYG{o}{)} \PYG{n}{ADProofs}\PYG{o}{.}\PYG{n+na}{foreach} \PYG{o}{(} \PYG{n}{ADProof} \PYG{o}{=\PYGZgt{}} \PYG{n}{History}\PYG{o}{.}\PYG{n+na}{apply}\PYG{o}{(}\PYG{n}{ADProof}\PYG{o}{))}
       \PYG{k}{if}\PYG{o}{(}\PYG{l+s}{\PYGZdq{}mode\PYGZdq{}}\PYG{o}{==}\PYG{l+s}{\PYGZdq{}pruned\PYGZhy{}full\PYGZdq{}} \PYG{o}{||} \PYG{l+s}{\PYGZdq{}mode\PYGZdq{}}\PYG{o}{==}\PYG{l+s}{\PYGZdq{}light\PYGZhy{}full\PYGZdq{}}\PYG{o}{)} \PYG{n}{drop} \PYG{n}{BlockTransactions} \PYG{n}{and} \PYG{n}{ADProofs} \PYG{n}{older} \PYG{n}{than} \PYG{n}{BlocksToKeep}
     \PYG{o}{\PYGZcb{}} \PYG{k}{else} \PYG{o}{\PYGZob{}}
       \PYG{c+c1}{//Drop Header from history, because it\PYGZsq{}s transaction sequence is not valid}
       \PYG{n}{History}\PYG{o}{.}\PYG{n+na}{drop}\PYG{o}{(}\PYG{n}{BlockTransactions}\PYG{o}{.}\PYG{n+na}{headerId}\PYG{o}{)}
     \PYG{o}{\PYGZcb{}}
  \PYG{o}{\PYGZcb{}} \PYG{k}{else} \PYG{o}{\PYGZob{}}
    \PYG{n}{blacklist} \PYG{n}{peer} \PYG{n}{who} \PYG{n}{sent} \PYG{n}{header}
  \PYG{o}{\PYGZcb{}}
\end{Verbatim}
