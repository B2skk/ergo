\documentclass[]{report}   % list options between brackets

\usepackage{color}
\usepackage{graphicx}
%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsthm package provides extended theorem environments
\usepackage{amsthm}
\usepackage{amsmath}

\usepackage{listings}

\usepackage{hyperref}


\newtheorem{axiom}{Axiom}

\newtheorem{proposition}{Proposition}
\newtheorem{definition}{Definition}

\def\shownotes{1}
\def\notesinmargins{0}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\knote}[1]{{\authnote{\textcolor{green}{Alex notes}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{red}{Dmitry notes}}{#1}}}


% type user-defined commands here
\usepackage[T1]{fontenc}

\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{titlesec}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstdefinestyle{myScalastyle}{
  frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
}
\newtheorem{claim1}{Claim}
\newtheorem{dfn}{Definition}
\newtheorem{defn}{Definition}
\newcommand{\ma}{\mathcal{A}}
\newcommand{\mb}{\mathcal{B}}
\newcommand{\he}{\hat{e}}
\newcommand{\sr}{\stackrel}
\newcommand{\ra}{\rightarrow}
\newcommand{\la}{\leftarrow}

\newcommand{\ignore}[1]{} % may contain useful stuff (that needs more work)
\newcommand{\full}[1]{} % use only for full version
\newcommand{\notfull}[1]{#1}
\newcommand{\rand}{\stackrel{R}{\leftarrow}}
\newcommand{\haya}{blue}
\newcommand{\amitabh}{purple}
\newcommand{\questions}{blue}
\newcommand{\defined}{\stackrel{\mbox{\tiny{def}}}{=}}
\newcommand{\mc}{\mathcal}
\newcommand{\ms}{\mathsf}
\newcommand{\txs}{\textsf}
\newcommand{\lea}{\leftarrow}
\newcommand{\rea}{\rightarrow}
\newcommand{\adv}{{\cal A} }
\def\kg{{\sf{Gen}}}
\def\enc{{\sf{Enc}}}
\def\dec{{\sf{Dec}}}
\newcommand{\btc}{\includegraphics[height=8pt]{assets/btc.jpg}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }

\newcommand{\dlog}{dlog(h)}
\newcommand{\pedersen}{pcom(h, c)}
\newcommand{\height}{\mathcal{H}}
\newcommand{\ergo}{$\Sigma$RGO}

\newcommand{\ecash}{$\Sigma$-Cash}

\newcommand{\edata}{$\Sigma$-Data}

\newcommand{\state}{\textit{State}}
\newcommand{\roller}{\textbf{Rollerchain}}
\newcommand{\aspen}{\textbf{Aspen}}
\newcommand{\bitcoinng}{\textbf{Bitcoin-ng}}
\newcommand{\sse}{\textbf{Space-Scarce Economy}}
\newcommand{\popow}{\textbf{PoPoW}}
\newcommand{\ads}{\textbf{ADS}}
\newcommand{\ssal}{\textbf{$\Sigma$SAL}}


\begin{document}

\title{The \ergo{} Yellowpaper}
\author{Alexander Chepurnoy \and Dmitry Meshkov}
\maketitle

\newpage
\tableofcontents

\section{Introduction}

\section{Multiple Modes}
\label{sec:modes}

Ergo (since the very first testing network Testnet0) is supporting  
multiple security models. In addition to fullnode mode, which is
similar to Bitcoin fullnode, Ergo reference implementation will 
support Light-SPV, Light-Fullnode, Pruned-Fullnode modes.
  
%For each mode, there is a corresponding value of a "mode" setting.

\subsection{Full-Node Mode}  
\label{sec:fullnode}

%("mode"="pruned-full" to enable this mode)
  
Like in Bitcoin, a full node is storing all the full blocks since 
genesis block. Full node checks proofs of work, linking structure 
correctness (parent block id, interlink elements), and all the 
transactions in all the blocks. A fullnode is storing all the full 
blocks forever. It is also holding full UTXO set to be able to validate an 
arbitrary transaction. 

The only optimization a fullnode is doing is that is is skipping downloading and checking 
AD-transformation block part (see below in the "Light-Fullnode" section).

   
\subsection{Pruned Full-Node Mode}
\label{sec:pruned}

%("mode"="pruned-full" to enable this mode)
   
This mode is similar to fast-sync in Geth or Grothendieck, warp-mode 
in Parity (all the three are Ethereum protocol clients), but makes
 more aggressive optimizations. In particular, a pruned-fullnode is 
 not downloading and storing full blocks not residing in a target 
 blockchain suffix, and also removing full blocks going out of the suffix.
 
In detail, a pruned client is downloading all the headers, then, by using them,
  it checks proofs-of-work and linking structure(or parent id only?). Then it downloads a UTXO 
  snapshot for some height from its peers. Finally, full blocks after the snapshot are to be downloaded
   and applied to get a current UTXO set.
 
A pruned fullnode is also skipping AD-transformation block part, like a fullnode.      
   
Additional setting: "suffix" - how much full blocks to store(w. some minimum set?)
   
   
\subsection{Light Full-Node Mode}   
\label{sec:light-fullnode}


%("mode"="light-full" to enable this mode)

This mode is based on an idea to use a 2-party authenticated dynamic dictionary built on top of
UTXO set. A light-fullnode holds only a root digest of a dictionary. It check all the full blocks, or some
suffix of the full blockchain, depending on setting, thus starting from a trusted pre-genesis digest or some digest in 
the blockchain. A light-fullnode is using AD-transformations (authenticated dictionary transformations) block section
containing batch-proof for UTXO transformations to get a new digest from an old one. It also checks all the transactions, 
but doesn't store anything but a single digest for that. Details can be found in the paper 
https://eprint.iacr.org/2016/994.

Additional settings : "depth" - from which block in the past to check transactions (if 0, then go from genesis)

"additional-checks" - %% of random blocks to check before the suffix, if "depth" is finite. To check, a 
light-fullnode trusts previous digest and checks current digest validity by using the previous one as well
 as AD-transformations.
 
"additional-depth" - depth to start additional checks from.  

\subsection{Light-SPV Mode}
\label{sec:light-spv}

%("mode"="light-spv" to enable this mode)

This mode is not about checking any full blocks. Like in Bitcoin, an SPV node is downloading block headers only,
and so checks only proofs of work and links. Unlike Bitcoin's SPV, the Light-SPV is downloading
 and checking not all the headers but a sublinear(in blockchain length) number of them(in benchmarks, this is about just
 tens of kilobytes instead of tens or hundreds of megabytes for Bitcoin/Ethereum).
 
Light-SPV mode is intended to be useful for mobile phones and low-end hardware. 

\subsection{Mode-Related Settings}

Ergo has the following settings determines a mode:
\begin{itemize}
  \item{ADState: Boolean} - keeps state roothash only 
  \item{VerifyTransactions: Boolean} - download block transactions and verify them (requires BlocksToKeep == 0 if disabled)
  \item{PoPoWBootstrap: Boolean} - download PoPoW proof only
  \item{BlocksToKeep: Int} - number of last blocks to keep with transactions, for all other blocks it keep header only. Keep all blocks from genesis if negative
  \item{MinimalSuffix: Int} - minimal suffix size for PoPoW proof (may be pre-defined constant)
\end{itemize}

`if(VerifyTransactions == false) require(BlocksToKeep == 0)`

Mode from **"multimode.md"** can be determined as follows:

%mode = if(ADState == false \&\& VerifyTransactions == true && PoPoWBootstrap == false && BlocksToKeep < 0) "full"
%else if(ADState == false && VerifyTransactions == true && PoPoWBootstrap == false && BlocksToKeep >= 0) "pruned-full"
%else if(ADState == true && VerifyTransactions == true && PoPoWBootstrap == false) "light-full"
%else if(ADState == true && VerifyTransactions == false && PoPoWBootstrap == true && BlocksToKeep == 0) "light-spv"
%else if(ADState == true && VerifyTransactions == true && PoPoWBootstrap == true && BlocksToKeep == 0) "light-full-PoPoW"
%else //Other combinations are possible


\section{Ergo Block Structure}

ErgoMinimalHeader is a minimal data amount, required to calculate blockId:


payloadRootHash: Array[Byte] - root hash (or simple hash of all payload data) of block payload
nonce: Int - field to iterate and generate valid PoW


ErgoHeader is a header to keep in History and transfer: 


---------------------------------------------------------------------------------------------
|Field            |  Size | Decription                                                      |
---------------------------------------------------------------------------------------------
|version          |  1    | block version, to be increased on every soft- and hardfork      |
|parentId         |  32   | id of parent block                                              |
|interlinksRoot   |  32   | root hash of interlinks structure                               |
|ADProofsRoot     |  32   | hash of ADProofs for transactions in a block                    |
|stateRoot        |  32   | root hash (for an AVL+ tree) of a state after block application |
|transactionsRoot |  32   | root hash (for a Merkle tree) of transactions in a block        |
|timestamp        |  8    | block timestamp(in milliseconds since beginning of Unix Epoch)  |
|nonce            |  8    | Proof-of-Work nonce                                             |
---------------------------------------------------------------------------------------------


Some of this fields may be calculated by node by itself:
- parentId: $if(status==bootstrap \land PoPoWBootstrap == false)$ (kushti: ???)
- interlinksRoot: $if(PoPoWBootstrap == false)$
- ADProofsRoot: $if(status==regular \land ADState==false \land BlocksToKeep>0)$ 
- stateRoot: $if(status==regular \land ADState==false \land BlocksToKeep>0)$ 

\section{Ergo Modifiers Processing}

This section describes processing algorithm for Ergo modifiers in all security modes.

Unlike most of blockchain systems, Ergo have the following types of **modifiers**:

In-memory:
\begin{itemize}
  \item{\em Transaction} - in-memory modifier
  \item{\em TransactionIdsForHeader} - ids of transactions of a block
  \item{\em UTXOSnapshotManifest} - ids of UTXO chunks and 
\end{itemize}

Persistent:
\begin{itemize}
  \item{\em BlockTransactions}  - Sequence of transactions, corresponding to 1 block.
  \item{\em ADProofs} - proof of transaction correctness relative to corresponding UTXO
  \item{\em Header} , that contains data required to verify PoW, link to previous block, state root hash and root hash to it's payload (BlockTransactions, ADProofs, Interlinks ...)
  \item{\em UTXOSnapshotChunk} - part of UTXO
  \item{\em PoPoWProof}
\end{itemize}

\subsection{Modifiers processing}


%def updateHeadersChainToBestInNetwork() = {
%  1.2.1. Send ErgoSyncInfo message to connected peers
%  1.2.2. Get response with INV message, containing ids of blocks, better than our best block
%  1.2.3. Request headers for all ids from 1.2.2.
%  1.2.4. On receiving header
%   if(History.apply(header).isSuccess) {
%      if(!(localScore == networkScore)) GOTO 1.2.1
%   } else {
%      blacklist peer
%      GOTO 1.2.1
%   }
%}


\subsection{Bootstrap}

%1.Download headers:
%if(PoPoW) {
%  1.1.1. Send GetPoPoWProof(suffix = Max(MinimalSuffix ,BlocksToKeep)) for all connections
%  1.1.2. On receive PoPoWProof apply it to History (History should be able to determine, whether this PoPoWProof is better, than it's current best header chain)
%} else {
%  updateHeadersChainToBestInNetwork()
%}


2.Download initial State to start process transactions:

%if(ADState == true) {
%  Initialize state with state roothash from block header BlocksToKeep ago
%} else if(BlocksToKeep < 0 || BlocksToKeep > History.headersHeight) {
%  Initialize state with genesis State
%} else {
%  //We need to download full state BlocksToKeep back in history
%  //TODO what if we can download state only "BlocksToKeep - N" or "BlocksToKeep + N" blocks back?
%  2.1. Request historical UTXOSnapshotManifest for at least BlocksToKeep back
%  2.2. On receiving UTXOSnapshotManifest: 
%    UTXOSnapshotManifest.chunks.foreach ( chunk => request chunk from sender() //Or from random fullnode)
%  2.3. On receiving UTXOSnapshotChunk
%  State.applyChunk(UTXOSnapshotChunk) match {
%     case Success(Some(newMinimalState)) => GOTO 3
%     case Success(None) => stay at 2.3 //we need more chunks to construct state. TODO periodicaly request missed chunks
%     case Failure(e) => ??? //UTXOSnapshotChunk or constcucted state roothash is invalid  
%  }
%}

3.Update State to best headers height

%  if(State.bestHeader == History.bestHeader) {
%    //Do nothing, State is already updated
%  } else if(VerifyTransactions == false) {
%    //Just update State rootshash to best header in history
%    State.setBestHeader(History.bestHeader)
%  } else {
%    //we have headers chain better then full block         
%    3.1. 
%      assert(history contains header chain from State.bestHeader to History.bestHeaders)
%      History.continuation(from = State.bestHeader, size = ???).get.foreach { header => 
%        sendToRandomFullNode(GetBlockTransactionsForHeader(header))
%        if(ADState == true) sendToRandomFullNode(GetADProofsForHeader(header))
%      }
%    3.2. On receiving modifiers ADProofs or BlockTransactions
%      //TODO History should return non-empty ProgressInfo only if it contains both ADProofs and BlockTransactions, or it contains BlockTransactions and ADState==false
%      if(History.apply(modifier) == Success(ProgressInfo)) {
%        if(State().apply(ProgressInfo) == Success((newState, ADProofs))) {
%          if(ADState==false) ADProofs.foreach ( ADProof => History.apply(ADProof))
%          if(BlocksToKeep>=0) remove BlockTransactions and ADProofs older than BlocksToKeep from history
%        } else {
%          //Drop Header from history, because it's transaction sequence is not valid
%          History.drop(modifier.headerId)
%        }
%      } else {
%        blacklistPeer
%      }
%      GOTO 3
%    }

4. GOTO regular mode


\subsection{regular}

Two infinite loops in different threads with the following functions inside:

1. $updateHeadersChainToBestInNetwork()$

2.Download and update full blocks when needed


%  if(State.bestHeader == History.bestHeader) {
%    //Do nothing, State is already updated
%  } else if(VerifyTransactions == false) {
%    //Just update State rootshash to best header in history
%    State.setBestHeader(History.bestHeader)
%  } else {
%    //we have headers chain better then full block         
%    3.1. Request transaction ids from all headers without transactions
%      assert(history contains header chain from State.bestHeader to History.bestHeaders)
%      History.continuation(from = State.bestHeader, size = ???).get.foreach { header => 
%        sendToRandomFullNode(GetTransactionIdsForHeader(header))
%        if(ADState == true) sendToRandomFullNode(GetADProofsForHeader(header))
%      }
%    3.2. On receiving TransactionIdsForHeader:
%      Mempool.apply(TransactionIdsForHeader)
%      TransactionIdsForHeader.filter(txId => !MemPool.contains(txId)).foreach { txId => 
%        request transaction with txId
%      }
%    3.3. On receiving a transaction:
%      if(Mempool.apply(transaction).isSuccess) {
%         Broadcast INV for this transaction
%         Mempool.getHeadersWithAllTransactions { BlockTransactions =>
%            GOTO 3.4 //now we have BlockTransactions
%         }
%      }
%    3.4. (same as 3.2. from bootstrap)
%  }

\section{Components}
\subsection{History}
\subsection{State}
\subsection{Memory Pool}

\section{Transactional Language}

\section{Protocol Updates}

\section{Peer-to-Peer Network}




\bibliographystyle{elsarticle-num}
\bibliography{sources.bib}
\addcontentsline{toc}{section}{References}

\end{document}
