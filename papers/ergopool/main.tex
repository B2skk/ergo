\documentclass[11pt]{article}
%\documentclass[runningheads]{llncs}
\def\shownotes{1}
\def\notesinmargins{0}

%\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{amsfonts}
% https://tex.stackexchange.com/questions/11719/how-do-i-backcolor-in-verbatim
\usepackage{xcolor}
\usepackage{alltt}
% Compensate for fbox sep:
\newcommand\Hi[2][lightgray]{%
	\hspace*{-\fboxsep}%
	\colorbox{#1}{#2}%
	\hspace*{-\fboxsep}%
}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
\newcommand{\powname}{Autolykos\xspace}
\newcommand{\poolname}{ErgoPool\xspace}
\newcommand{\mixname}{ErgoMix\xspace}


\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}

\newcommand{\primname}{Commitment of Work\xspace}
\newcommand{\prim}{CoW\xspace}


\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}


\title{Bypassing Non-Outsourceability in Proof-of-Work Puzzles Using Smart Contracts}
\author{Ergo Developers}
%\institute{Ergo Platform}
\maketitle

\begin{abstract}
% 	Ergo is a 
	Non-outsourceable puzzles have been proposed to prevent mining pool formation in Proof-of-work (PoW) platforms. In this work, we show how bypass such restrictions provided the underlying platform supports smart contracts in a sufficiently advanced language. In particular, the language should allow access to the PoW solution and use it in creating guard conditions. We demonstrate a practical implementation of our attack using \poolname, a pool for Ergo, which is an advanced smart contract platform designed to be pool-resistant. Our approach allows complete centralization of mining, where the pool operator not only collects the rewards but also decided which transactions to accept. 
	
\end{abstract}

\section{Introduction}
\snote{Below text copied from PoW intro paper}

Blockchain platforms such as Ethereum and Ergo provide advanced financial capabilities using sophisticated guard scripts, which are also called smart contracts. While Ethereum is an account based platform, Ergo follows the more traditional UTXO model. This allows Ergo to be more scalable than Ethereum in the long run, at least when it comes to memory and computation requirements of participant nodes. 
Another dimension of long-term scalability in blockchain platforms is how well it is able to withstand some of the following threats:
\begin{enumerate}
    \item Centralization of mining power
    \item Transaction censorship
    \item Forking attacks, where it is difficult to select the correct chain due to a large number of forks of identical difficulty parameters.
\end{enumerate}

Non-outsourcable puzzles have been proposed to prevent the first two but not the third. In fact some approaches to non-outsourceable puzzles increase the chances of forking attacks, where there were none in the original scheme (Type 1 schemes below). 

In this work, we describe an approach using smart contracts to bypass the non-outsorceability of most such approaches. 

% Ergo\footnote{\url{https://ergoplatform.org}} is a smart contract platform whose contracts are written in a high-level language called \langname. It provides Ethereum-like functionality but is more closer to Bitcoin in the underlying design. For instance, it is based on short-lived immutable objects (called UTXOs in Bitcoin and {\em boxes} in Ergo) instead of long-lived mutable objects (called accounts in Ethereum) to store data and code. It also has some features different from both Bitcoin and Ethereum relating to scalability and long-term survivability. For instance, it has a {\em storage-rent} component, so that boxes must pay rent to continue staying on the blockchain. Secondly, it allows running a fully verifying node on low-power devices using the idea of partially stateless clients implementation~\cite{RMCI17}. Finally, it uses a PoW algorithm called \powname~\cite{autolykos} that discourages mining-pool formation, which we informally term {\em pool-resistance}. 

\section{Background}
\subsection{Outsourceable Puzzles}

Below describes how generic outsourceable puzzles work. 

\snote{Following is more or less copy-pasted from PoW intro paper. Needs rework}


In Bitcoin, a miner collects a number of unconfirmed transactions and concatenates them using a Merkle tree. All nodes of this tree except the leaves are 32 byte hashes computed from its children. The root of this tree, denoted $t$ here, is stored in another structure called the {\em block header}, which also includes the hash of the previous block's header $h$ and a random string $n$ called the nonce. We use the term $m$ to denote the concatenation of Merkle root and the hash of the previous block. 
That is, $m = t\|h$ and the header is of the form $m\|n$. 

The solution is also determined by another parameter $b < 2^{256}$, denoting the `difficulty'. Let $H$ be a collision resistant hash function taking as input an arbitrary sized array of bits and outputting an array of 256 bits. The output of $H$ can be considered a number between 0 and $2^{256}-1$. The header $m\|n$ is considered a valid solution if $H(m\|n) \leq b$. 

A miner repeatedly tries different values of $n$ (possibly changing $m$ as well by including new transactions in between tries) until a solution is found. Since the output of $Hash$ can be thought of as distributed uniformly in the output space, the probability of finding a solution in each try is $\tau = b/2^{256}$. All proof-of-work algorithms (including that of Ergo) follow this basic idea of restricting the output to be less than some $b$. It is worth noting that, for Bitcoin, as of this writing (July 2019), $b\approx 2^{181}$, and so $\tau \approx 2^{-75}$. %\approx 10^{-22.6} \approx 0.0000000000000000000000257$.

\textbf{Mining Pools:} Bitcoin allows mining pools, which roughly work as follows. The pool distributes work, based on a some $m$ that it decides. Each miner tries to find a solution for the given $m$ and any solution found is sent to the network. 
A miner actually tries to find a {\em share}, which is like a solution but with reduced difficulty (also decided by the pool). Some of the shares may also be real solutions, which become valid blocks. A miner gets paid by the number of shares submitted.
The key observation with pools is that miners do work for some other entity who then distributes the rewards back to the workers.
We define three levels of centralization in pools. 

\begin{enumerate}
	\item {\em Level 1 (Complete centralization):} The pool operator is defines both $m$ and the reward address. Thus, a pool operator has full control over which transactions are included (censorship) and also carries the risk of losing the rewards.
	\item {\em Level 2 (Partial centralization):} The pool operator does not defines $m$ but collects the rewards. This is resistant to censorship but still carries the risk of losing the rewards. This is what we will try achieve. 
	\item {\em Level 3 (No centralization):} There is no pool operator and rewards are automatically given to the participants based on the shares they submitted (P2Pool for Bitcoin and SmartPool for Ethereum).
\end{enumerate}
We also add another parameter, namely {\em mineability}, which captures the ability of miners with smaller investments to join and receive small but frequent rewards rather than large but infrequent ones, despite the yield of the latter being larger over a long time. If the system does not allow smaller miners to receive any rewards in a reasonable time, we say that the system has low mineability and is only suitable for larger miners (and will eventually lead to centralization). A system with high mineability allows miners to receive a steady income to cover running costs their mining equipment, thereby encouraging such miners to join and keep the mining power spread over a larger network.
The following table summarizes the concepts.\\

	\begin{tabular}{lllll}
		& Level & Censorship & Reward Risk & Mineability \\\hline
		& 1 (full centralization)    & Yes & Yes & High \\
		& 2 (partial centralization)    & No & Yes & High \\
		& 3 (no centralization)    & No & No & Low
	\end{tabular}

~\\

Note that P2Pool and SmartPool operate at Level 3 but maintain high minability because they only work in systems that also support Levels  1 and 2. In particular, these approaches don't work in systems that are designed to operate only in Level 3, such as the non-outsourceable puzzles of~\cite{} (see next Section). 

Ergo is also designed as a Level 3 platform. However, Ergo's scripting language, \langname enables us to create \poolname, a mining pool for Ergo that operates at Levels 1 and 2. In particular, we use the block solution (available as contextual information in \langname) to define a pooled mining contract.

\subsection{Non-Outsourceable Puzzles}

Discuss weak and strong variants; pool resistance; other works

We start with overviewing (non-)outsourceability definitions in existing literature. Different works, such as
Non-outsourceable Scratch-Off Puzzles~\cite{miller2015nonoutsourceable}, 2-Phase Proof-of-Work (2P-PoW)~\cite{twophase},
PieceWork~\cite{daian2017short}, Autolykos~\cite{autolykos}.


Non-outsourceability definitions could be simply split into two classes. In the first one~\cite{miller2015nonoutsourceable}, which we call \textbf{Type 1} it is assumed that a Proof-of-Work scheme is non-outsourceable if for a generated block a miner can generate another one
efficiently with a non-negligible probability. Motivation behind this definition is that a miner can get paid for shares
by generating trying to generate a block for the pool. In case of successful block generation, however, miner is supposedly generating
another block for which rewards are going to the miner instead of the pool. 

In the other category~\cite{autolykos, daian2017short, twophase}, contrary, called \textbf{Type 2}, a scheme is called
non-outsourceable if is it not possible to iterate over solution space without knowing a secret, with block rewards
associated with a public image~(key). The reasoning here is that the pool is not trusting the miner and so will not give
the secret away to him.  

Both approach rely on the attacker creating a race condition to steal the pool's rewards. The difference lies in the way this occurs. In Type 1, any party is able to generate a solution $d$ for some block header $m$ that sends rewards to a pool address, then the same party can then efficiently generate another solution $d'$ for an $m'$ that sends rewards to any other chosen address. This results in a race condition where the party can steal the rewards if the solution to $m'$ gets accepted. In particular the race condition occurs {\em before} a block is finalized into the blockchain. We further classify Type 1 into {\em weak} if the identity of the miner stealing the rewards is public and {\em strong} if it is secret. 

Type 2 uses the fact that the economic goal of non-outsourceability of~\cite{miller2015nonoutsourceable} is preserved if the ability to steal the rewards is present in the spending stage rather than in the mining stage. That is, any party that generates a valid solution for $m$ then has the ability to spend the reward transaction of $m$ in an untraceable manner. 
In particular, for Type 2 schemes, the race condition occurs {\em after} a block is accepted. 

We note that all Type 1 schemes have an inherent problem that allows malicious actors to flood the network with a large number of valid but distinct solutions, thereby causing network partitions and instability. This causes the network to converge very slowly or result in several forks. Hence, we don't consider Type 1 schemes to be robust in reaching consensus, thereby making them impractical in the real world. We call this the {\em forking attack}. Strong Type 1 schemes are even more prone to this attack because there is no fear of detection (and penalization). 

In this work, we break the non-outsourceability of all Type 2 and weak Type 1 schemes assuming that their platforms support
some minimal smart contract capability. The following table summarizes the current state-of-the-art. 


	\begin{tabular}{llllll}
		  Type     & Identity   & Block Rewards Stolen       & Forking attack & Broken \\\hline
		  1 strong & secret           & before acceptance  & yes            & no\\
		  1 weak   & public           & before acceptance  & yes            & this work\\
		  2        & any              & after acceptance   & no             & this work
	\end{tabular}

% In this view, Ergo is a special instance of a non-outsourceable puzzle of~\cite{miller2015nonoutsourceable}, where the contention is not to generate a new message $m'$, that sends the reward to a different address (which is not possible in Ergo). Instead the goal is to steal the reward 720 blocks later, when it becomes spendable. 

\subsection{Overview of Execution Context in Ergo}

To give understanding of how a smart contract can bypass non-outsourceability, we first explain what kind of data the contract
can access.

In Proof-of-Work currencies a block is split usually into sections, with a compact section called {\em header} which is
enough to verify Proof-of-Work puzzle solution and also to check integrity of other sections (such as block transactions).

Execution context is what available to a contract during execution. Considering UTXO-based cryptocurrencies, such as
Bitcoin and Ergo, we can think about following components of the execution context. In the first place, smart contract
 may have access to the UTXO it is locking (e.g. monetary value of the UTXO). In the second place, smart contract may
 have access to the spending transaction with its inputs and outputs. In the third place, smart contract may have access
 to block header data. For example, in Ergo last ten block headers and also parts of the next block header which could
 be known to the miner before starting mining of the new block do belong to the execution context. Finally, execution
 context may contain the full block with all its transactions. Please note, as execution context must be fit into
 random-access memory of commodity hardware, accessing full blockchain is not the realistic case. Table \ref{???}
 summarizing possible execution context components.


\begin{tabular}{llllllll}
	& Level & UTXO & Transaction & Header      & Block & Example \\ \hline
	& 1     & No  & No          & No  		   & No    & Bitcoin \\
	& 2     & Yes & Yes         & No 		   & No    & -- \\
	& 3     & Yes & Yes         & Yes 		   & No    & Ergo    \\
	& 4     & Yes & Yes         & Yes 		   & Yes   & --    \\
\end{tabular}
	
\section{Non-Outsourceable Puzzles}

% Ergo uses \powname as its underlying proof-of-work mechanism and Ergo's reward system can be considered as a type of PieceWork puzzle \snote{Check validity of this statement}. 

We first describe the basic Type 2 approach in detail before describing our approach in the next section.
In a nutshell, this method uses a combination of two techniques: (1) replacing the core hash function with a digital signature (i.e., using public-key cryptography) and (2) tying the public key to the rewards. 

\subsection{Using Public-Key Cryptography}

The method requires a randomized signature scheme that is strongly unforgeable against adaptive chosen message attacks (s-UFCMA)) and outputs signatures uniformly spread over $\mathbb{Z}_{2^{256}}$ irrespective of how the signer behaves. Schnorr signature scheme is one such scheme.  

A candidate block header is constructed using transactions as in Bitcoin along with a public key $pk$. A valid block header is a candidate block header along with a signature $s$ that (1) verifies with this public key and (2) satisfies the difficulty constraints as in bitcoin (i.e., is less than a certain value).

The difficulty parameter is automatically adjusted to ensure consistent time between solutions. 
% At this point we must distinguish between two types of reward mechanisms. The first is where the rewards are {\em created} at the time of mining, also termed as {\em post-mine}. The second is where the rewards are {\em unlocked} at the time of mining, but were created much earlier {\em pre-mine}. 

% Using this terminology, we can say that an Ergo-like system does not prevent pools for post-mined rewards but can be made pool-resistant for pre-mined rewards, as discussed next.

\subsection{Tying Public-Key to Rewards}

The second technique in making a Type 2 pool-resistant scheme is to tie the rewards to the public key corresponding to the block solution. That is, the platform enforces that any mining rewards are protected by the statement {\em prove knowledge of secret key corresponding to the public key $pk$ (from the block solution)}

Rather than enforcing this logic within the protocol, Ergo uses smart contracts to enforce it. In particular, this rule is enforced in a so called \textbf{Emission box}, a UTXO which contains all the ergs that will ever be emitted in rewards. The box is protected by a script that enforces certain conditions on how the rewards must be collected. In particular, it requires that a reward transaction has exactly two outputs, such that the first is another emission box containing the remaining ergs and the second is a box with the miners reward (initially 67.5 Ergs) protected using the script: {\em prove knowledge of the discrete logarithm (to some fixed base $g$) of group element $pk$ AND height is greater than or equal to the box-creation height plus 720}.  
This is possible because Ergo's (Level 3) context includes the block solution.  

The above approach ensures that the private key used for finding the block solution is also needed for spending the rewards. Consequently, anyone who finds a block also has the ability to spend those rewards. 
If we try to create any standard type of pool, we find that anyone having the ability to find a solution also has the ability to spend (i.e., steal) the reward. In fact, any standard pool must share the same private key among all participants, thereby making it impossible to determine the actual spender. This restriction also applies to decentralized schemes such as P2Pool and SmartPool because they both require the miner be able to use arbitrary public keys for receiving the reward

% Note that the same richness of \langname that allows it be pool-resistant (at least to standard pooling techniques) also allows us break pool-resistance using non-standard techniques. In this paper we discuss two such methods.  

\snote{Discuss how \powname fits (which) definition of non-outsourceable puzzles.}

\subsection{Comparing with Non-Outsourceable Puzzles}

A non-outsourceable puzzle is one with the following properties~\cite{miller2015nonoutsourceable}. If any party is able to generate a solution $d$ for some block header $m$ that sends rewards to a pool address, then the same party can then efficiently generate another solution $d'$ for an $m'$ that sends rewards to any other chosen address, and that too without revealing the identity. This results in a race condition where the party can steal the rewards if the solution to $m'$ gets accepted, thereby making it non-outsourceable. 

We note that non-outsourceability of~\cite{miller2015nonoutsourceable} is preserved if the ability to steal the rewards is present in the spending stage rather than in the mining stage. That is, any party that generates a valid solution for $m$ then has the ability to spend the reward transaction of $m$ in an untraceable manner. 
In this view, Ergo is a special instance of a non-outsourceable puzzle of~\cite{miller2015nonoutsourceable}, where the contention is not to generate a new message $m'$, that sends the reward to a different address (which is not possible in Ergo). Instead the goal is to steal the reward 720 blocks later, when it becomes spendable. 

\section{Creating an Ergo Mining Pool}

Despite Ergo being a special instance of a non-outsourceable puzzle, there is a way to create a pool in Ergo that does not generalize to other instances of such puzzles. Thus, Ergo serves as a counterexample  
that all instances of non-outsourceable puzzles are pool resistant. This sections describes a way to create an Ergo mining pool. 

\textbf{Basic variant:} We first describe a basic version that is insecure, and thereby does not work for general non-outsourceable puzzles. However, Ergo has certain features (or bugs) that enable us to patch this vulnerability, thereby breaking its non-outsourceability. We demonstrate this in the full version by extending the basic one. 

The key observation is that in a valid share, the reward need not necessarily be sent directly to the pool's address. What is actually necessary is that an amount equivalent to the reward is sent to the pool's address. This simple observation allows us to create a pool with the following rules:
\begin{enumerate}
	\item Each miner can send the reward to his own public key $p$, whose secret key only he knows ({\em reward transaction}).
	\item The block must also have another transaction sending the same amount as the reward to the pool address ({\em pool transaction}).
\end{enumerate}

A valid share is a solution to a block with the above structure. A pool operator collects such shares and any funds thus received are distributed among the miners based on the number of shares they submitted. One drawback of this is that each miner must have an equivalent amount of ergs to cover the reward amount at any time, even though the reward become spendable only after 720 blocks. 
This means that in order to continue mining after a block is found, each miner must keep the reserved amount of at least 2 rewards (possibly more depending on the expected time to find a block).

 To overcome this drawback, a pool may provide incentives such as allowing the miner to keep a small fraction of the reward (example for the current reward of 67.5 ergs, the pool may require only 65 ergs to be sent to it). A pool transaction can pay to any pool defined address. For instance, it could be a P2SH address of \texttt{poolPubKey}. 


\textbf{The broadcast attack:} Let Alice be a miner with public key $alice$. If such a system is used in, say Bitcoin, then the system becomes insecure. Once the pool-paying transaction is publicized, anyone (not necessarily Alice) may broadcast it (possibly by using it as their own pool transaction). 

\textbf{Full variant:} The full protocol mitigates the above attack. This is possible because \langname allows us to use the block solution in the context, using which we can secure the pool transaction as follows. Instead of paying to the pool from an arbitrary box (or boxes), Alice will instead store these funds in a special box protected by the following script:
\begin{verbatim}
(minerPubKey == alice) || bob
\end{verbatim}
The first part ensures that when used to fund the pool output, the miner must be Alice. The second ensures that the coins are not stuck till Alice finds a block (if ever). Here \texttt{bob} is another public key owned by Alice.

Note that the above attack mitigation strategy is unique to Ergo and will not work in generic pool-resistant protocols described in~\cite{miller2015nonoutsourceable}. One may envisage a hiding strategy, where the pool transaction is not revealed in a share (only a commitment is revealed). The actual transaction is revealed only for claiming shares or if a block is found. However, this is also insecure as discussed below. First note that there are two types of broadcast attacks. The first is the ``extract from share'' attack discussed above. The second is the ``extract from orphaned block'' attack, where the transaction is extracted from a mined block that ends up getting orphaned. While the hiding strategy works for the first attack, it does not mitigate the second. 


% \section{\poolname}

% \subsection{Security Aspects}

% Broadcast attack and its variants. How to prevent it if smart contract language does not allow access to mining solution?

\subsection{Decentralized \poolname}

How to make it work like SmartPool or P2Pool

\section{Conclusion}

\bibliographystyle{unsrt}
\bibliography{main}
\appendix


\end{document}
