\documentclass[11pt]{article}
%\documentclass[runningheads]{llncs}
\def\shownotes{1}
\def\notesinmargins{0}

%\usepackage{fullpage}

\usepackage{mathtools,color,xcolor,hyperref,graphicx,wrapfig,listings,array,xspace}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage{amsfonts}
% https://tex.stackexchange.com/questions/11719/how-do-i-backcolor-in-verbatim
\usepackage{xcolor}
\usepackage{alltt}
% Compensate for fbox sep:
\newcommand\Hi[2][lightgray]{%
	\hspace*{-\fboxsep}%
	\colorbox{#1}{#2}%
	\hspace*{-\fboxsep}%
}

\ifnum\shownotes=1
\ifnum\notesinmargins=1
\newcommand{\authnote}[2]{\marginpar{\parbox{\marginparwidth}{\tiny %
  \textsf{#1 {\textcolor{blue}{notes: #2}}}}}%
  \textcolor{blue}{\textbf{\dag}}}
\else
\newcommand{\authnote}[2]{
  \textsf{#1 \textcolor{blue}{: #2}}}
\fi
\else
\newcommand{\authnote}[2]{}
\fi

\newcommand{\lnote}[1]{{\authnote{\textcolor{orange}{Leo notes}}{#1}}}
\newcommand{\snote}[1]{{\authnote{\textcolor{yellow}{Scalahub notes}}{#1}}}
\newcommand{\knote}[1]{{\authnote{\textcolor{green}{kushti notes}}{#1}}}
\newcommand{\mnote}[1]{{\authnote{\textcolor{red}{Morphic}}{#1}}}
\newcommand{\dnote}[1]{{\authnote{\textcolor{brown}{Dima notes}}{#1}}}

\newcommand{\ret}{\mathsf{ret}}
\newcommand{\new}{\mathsf{new}}
\newcommand{\hnew}{h_\mathsf{new}}
\newcommand{\old}{\mathsf{old}}
\newcommand{\op}{\mathsf{op}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\key}{\mathsf{key}}
\newcommand{\nextkey}{\mathsf{nextKey}}
\newcommand{\node}{\mathsf{t}}
\newcommand{\parent}{\mathsf{p}}
\newcommand{\leaf}{\mathsf{f}}
\newcommand{\vl}{\mathsf{value}}
\newcommand{\balance}{\mathsf{balance}}
\newcommand{\lft}{\mathsf{left}}
\newcommand{\rgt}{\mathsf{right}}
\newcommand{\lbl}{\mathsf{label}}
\newcommand{\direction}{\mathsf{d}}
\newcommand{\oppositedirection}{\bar{\mathsf{d}}}
\newcommand{\found}{\mathsf{found}}
\newcommand{\mypar}[1]{\smallskip\noindent\textbf{#1.}\ \ \ }
\newcommand{\ignore}[1]{}

\newcommand{\langname}{ErgoScript\xspace}
\newcommand{\powname}{Autolykos\xspace}
\newcommand{\poolname}{ErgoPool\xspace}
\newcommand{\mixname}{ErgoMix\xspace}


\newcommand{\lst}[1]{\text{\lstinline[basicstyle={\ttfamily}]$#1$}}

\newcommand{\andnode}{\ensuremath{\mathsf{AND}}}
\newcommand{\ornode}{\ensuremath{\mathsf{OR}}}
\newcommand{\tnode}{\ensuremath{\mathsf{THRESHOLD}}}

\newcommand{\primname}{Commitment of Work\xspace}
\newcommand{\prim}{CoW\xspace}


\newcommand{\GF}{\ensuremath{\mathrm{GF}}}


\begin{document}


\title{Bypassing Non-Outsourceability in Proof-of-Work Puzzles Using Collateralized Smart Contracts}
\author{Ergo Developers}
%\institute{Ergo Platform}
\maketitle

\begin{abstract}
    Centralized pools and renting of mining power are considered as sources of possible censorship threats and even 51\%
    attacks for decentralized cryptocurrencies. Non-outsourceable Proof-of-Work schemes have been proposed to tackle these issues. However, tenets in the folklore say that such schemes could potentially be bypassed using escrow mechanisms.
    In this work, we propose a concrete example of such a mechanism using collateralized smart contracts. Our approach allows miners to bypass non-outsourceable Proof-of-Work schemes 
    if the underlying blockchain platform supports smart contracts in a sufficiently advanced language. In particular, the language
    should allow access to the PoW solution.
    At a high level our approach is for the miner to lock collateral covering the reward amount protected by a smart contract which acts as a trusted escrow. The smart contract has logic that allows the pool to collect the collateral as soon as the miner collects any block reward. We propose two variants of the approach depending on when the collateral is bound to the block solution. Using this, we show how to bypass
    previously proposed non-outsourceable Proof-of-Work schemes~(with the notable exception for strong non-outsourceable scheme
    \knote{link}) and show how to build mining pools for such schemes.

	% Non-outsourceable puzzles have been proposed to prevent mining pool formation in Proof-of-work (PoW) platforms.
	% In this work, we show how bypass such restrictions provided the underlying platform supports smart contracts in a
	% sufficiently advanced language. In particular, the language should allow access to the PoW solution and use it
	% in creating guard conditions. We demonstrate a practical implementation of our attack using \poolname, a pool for
	% Ergo, which is an advanced smart contract platform designed to be pool-resistant. Our approach allows complete
	% centralization of mining, where the pool operator not only collects the rewards but also decided which
	% transactions to accept.
\end{abstract}

\section{Introduction}

Security of Bitcoin and many other cryptocurrencies relies on so called Proof-of-Work (PoW) schemes~(also known as scratch-off puzzles), which are mechanisms to reach fast consensus and guarantee immutability of the ledger. Security of such consensus mechanisms is based on the assumption that no single entity controls a large part of the mining power. For example, if a single entity controls
33\% then it can earn unproportionally more rewards using {\em selfish mining}~\cite{selfish}, and with more than 50\% an adversary can do double spending or filter out certain transactions. However,  individually, it is more beneficial for a miner to join a pool despite the fact that it is detrimental to the system as a whole since it causes concentration of mining power. Another threat, especially for new cryptocurrencies are potential Goldfinger attacks using hosted mining services to rent mining power in order to mine~(or attack) a cryptocurrency~\cite{goldfinger}. Non-outsourceable puzzles have been proposed to address these issues~\cite{miller2015nonoutsourceable,daian2017short}.\knote{links}. Such approaches require reward spending to depend on some trapdoor information used in solution generation. A notable example of a real world implementation of this idea is Ergo~\cite{ergo}, whose PoW, \powname, is based on~\cite{daian2017short}. In this work, we describe how to bypass the non-outsourceability of many such schemes, including Ergo. 

The rest of the paper is organized as follows [...]
\section{Background}

\subsection{Proofs of Work} 

We first describe the vanilla proof-of-work mechanism used in Bitcoin. A miner collects a number of unconfirmed transactions and builds a Merkle tree on top of them.
% All nodes of this tree except the leaves are 32 byte hashes computed from its children.
The digest of this tree, denoted $t$ here, is stored in a section of the block called the {\em block header}, which also includes the hash of the previous block's header $h$ and a random string $n$ called the nonce. We use the term $m$ to denote the puzzle made of the concatenation of the Merkle tree digest and the hash of the previous block. That is, $m = t\|h$ and
then the header is of the form $m\|n$.
The solution is also determined by another parameter $\lambda > 1$, called the {\em difficulty}. Let $H$ be a collision
resistant hash function with output of 256 bits. 
The header $m\|n$ is considered a valid solution
if $H(m\|n) \leq 2^{256}/\lambda$.
A miner repeatedly tries different values of $n$ (and possibly $m$) until a solution is found. 
Since $H$ is like a random oracle, the probability of fining a solution in one attempt is 
$1 / \lambda$.\footnote{It is worth mentioning that as of July 2019, this value is $\approx 2^{-75}$.} %\approx 10^{-22.6} \approx 0.0000000000000000000000257$.
All PoW-based systems use the above idea of finding a value from a uniform distribution that falls within some narrower range computed using the difficulty parameter. 

\subsection{Pooled Mining} 

Bitcoin allows mining pools, which roughly work as follows. The pool distributes work, based on a some $m$ that it decides. Each miner tries to find a solution for the given $m$ and any solution found is sent to the network.
A miner actually tries to find a {\em share}, which is like a solution but with reduced difficulty (also decided by the pool). Some of the shares may also be real solutions, which become valid blocks. A miner gets paid by the number of shares submitted.
The key observation with pools is that miners do work for some other entity who then distributes the rewards back to the workers.
We define three levels of centralization in pools.

\begin{enumerate}
	\item {\em Level 1 (Complete centralization):} The pool operator defines both $m$ and the reward address. Thus, a pool operator has full control over which transactions are included (censorship) and also carries the risk of losing the rewards.
	\item {\em Level 2 (Partial centralization):} The pool operator does not define $m$ but collects the rewards. This is resistant to censorship but still carries the risk of losing the rewards. This is what we will try achieve.
	\item {\em Level 3 (No centralization):} There is no pool operator and rewards are automatically given to the participants based on the shares they submitted (see P2Pool for Bitcoin and SmartPool for Ethereum).
\end{enumerate}
% We also add another parameter, namely {\em mineability}, which captures the ability of miners with smaller investments to join and receive small but frequent rewards rather than large but infrequent ones, despite the yield of the latter being larger over a long time. If the system does not allow smaller miners to receive any rewards in a reasonable time, we say that the system has low mineability and is only suitable for larger miners (and will eventually lead to centralization). A system with high mineability allows miners to receive a steady income to cover running costs their mining equipment, thereby encouraging such miners to join and keep the mining power spread over a larger network.
The following table summarizes the concepts.\\

	\begin{tabular}{lllll}
		& Pool Level & Censorship Possible & Reward theft risk\\\hline
		& 1 (full centralization)    & Yes & Yes \\
		& 2 (partial centralization)    & No & Yes \\
		& 3 (no centralization)    & No & No 
	\end{tabular}

% ~\\

% Note that P2Pool and SmartPool operate at Level 3 but maintain high minability because they only work in systems that also support Levels  1 and 2. In particular, these approaches don't work in systems that are designed to operate only in Level 3, such as the non-outsourceable puzzles of~\cite{} (see next Section).

% Ergo is designed to be pool-resistant, and thus, not allow pooling at any level. However, Ergo's scripting language, \langname enables us to create \poolname, a mining pool for Ergo that operates at Levels 1 and 2. In particular, we use the block solution (available as contextual information in \langname) to define a pooled mining contract.


%\snote{Below text copied from PoW intro paper}

%Blockchain platforms such as Ethereum and Ergo provide advanced financial capabilities using sophisticated guard scripts, which are also called smart contracts. While Ethereum is an account based platform, Ergo follows the more traditional UTXO model. This allows Ergo to be more scalable than Ethereum in the long run, at least when it comes to memory and computation requirements of participant nodes.
%Another dimension of long-term scalability in blockchain platforms is how well it is able to withstand some of the following threats:
%\begin{enumerate}
%    \item Centralization of mining power
%    \item Transaction censorship
%    \item Forking attacks, where it is difficult to select the correct chain due to a large number of forks of identical difficulty parameters.
%\end{enumerate}

%Non-outsourcable puzzles have been proposed to prevent the first two but not the third. In fact some approaches to non-outsourceable puzzles increase the chances of forking attacks, where there were none in the original scheme (Type 1 schemes below).

%In this work, we describe an approach using smart contracts to bypass the non-outsorceability of most such approaches.

% Ergo\footnote{\url{https://ergoplatform.org}} is a smart contract platform whose contracts are written in a high-level language called \langname. It provides Ethereum-like functionality but is more closer to Bitcoin in the underlying design. For instance, it is based on short-lived immutable objects (called UTXOs in Bitcoin and {\em boxes} in Ergo) instead of long-lived mutable objects (called accounts in Ethereum) to store data and code. It also has some features different from both Bitcoin and Ethereum relating to scalability and long-term survivability. For instance, it has a {\em storage-rent} component, so that boxes must pay rent to continue staying on the blockchain. Secondly, it allows running a fully verifying node on low-power devices using the idea of partially stateless clients implementation~\cite{RMCI17}. Finally, it uses a PoW algorithm called \powname~\cite{autolykos} that discourages mining-pool formation, which we informally term {\em pool-resistance}.

%\section{Background}
%\subsection{Outsourceable Puzzles}

%Below describes how generic outsourceable puzzles work.

%\snote{Following is more or less copy-pasted from PoW intro paper. Needs rework}


% In Bitcoin, a miner collects a number of unconfirmed transactions and concatenates them using a Merkle tree. All nodes of this tree except the leaves are 32 byte hashes computed from its children. The root of this tree, denoted $t$ here, is stored in another structure called the {\em block header}, which also includes the hash of the previous block's header $h$ and a random string $n$ called the nonce. We use the term $m$ to denote the concatenation of Merkle root and the hash of the previous block.
% That is, $m = t\|h$ and the header is of the form $m\|n$.

%The solution is also determined by another parameter $b < 2^{256}$, denoting the `difficulty'. Let $H$ be a collision resistant hash function taking as input an arbitrary sized array of bits and outputting an array of 256 bits. The output of $H$ can be considered a number between 0 and $2^{256}-1$. The header $m\|n$ is considered a valid solution if $H(m\|n) \leq b$.

%A miner repeatedly tries different values of $n$ (possibly changing $m$ as well by including new transactions in between tries) until a solution is found. Since the output of $Hash$ can be thought of as distributed uniformly in the output space, the probability of finding a solution in each try is $\tau = b/2^{256}$. All proof-of-work algorithms (including that of Ergo) follow this basic idea of restricting the output to be less than some $b$. It is worth noting that, for Bitcoin, as of this writing (July 2019), $b\approx 2^{181}$, and so $\tau \approx 2^{-75}$. %\approx 10^{-22.6} \approx 0.0000000000000000000000257$.


\subsection{Non-Outsourceable Puzzles}

% Discuss weak and strong variants; pool resistance; other works

We start with overviewing (non-)outsourceability definitions in existing literature. Different works, such as
Non-outsourceable Scratch-Off Puzzles~\cite{miller2015nonoutsourceable}, 2-Phase Proof-of-Work (2P-PoW)~\cite{twophase},
PieceWork~\cite{daian2017short}, Autolykos~\cite{autolykos}.


Non-outsourceability approaches can be broadly divided into two categories. In the first one~\cite{autolykos, daian2017short, twophase}, which we call \textbf{Type 1}, a scheme is considered
non-outsourceable if it is not possible to iterate over the solution space without knowing some trapdoor information (such as a secret key) corresponding to some public information (such as a public key) contained in the block header, with block rewards locked by that trapdoor information. The reasoning here is that in order to send the reward to a pool's address, each miner must know the secret corresponding to that address. However, a pool does not trust miners and so will not give the secret away to them. 

In the other category
~\cite{miller2015nonoutsourceable}, called \textbf{Type 2}, a Proof-of-Work scheme is considered non-outsourceable if for any solved block, a miner can generate another block efficiently with non-negligible probability. The motivation behind this definition is that a miner can get paid for shares
by trying to generate a block that pays the reward to the pool. In case of successful block generation, however, the miner could generate and broadcast another block that sends the reward to the miner instead of the pool. 
We further classify Type 2 into {\em weak} if the identity of the miner stealing the rewards can be ascertained and {\em strong} if the identity remains secret.

At a technical level, both Type 1 and 2 approaches rely on a miner's ability to steal the pool's rewards. The difference lies in the way this occurs. In Type 1 schemes, the miner is able to steal the reward {\em after} the block gets finalized.
% while in Type 2 schemes, this happens before block finilzation. 
% That is, any party that generates a valid solution for $m$ then has the ability to spend the reward transaction of $m$ in an untraceable manner. 
% In particular, the theft happens {\em after} a block is accepted, whil.
In Type 2, 
% any party is able to generate a solution $d$ for some block header $m$ that sends rewards to a pool address, then the same party can then efficiently generate another solution $d'$ for an $m'$ that sends rewards to any other chosen address. This results in a race condition where the party can steal the rewards if the solution to $m'$ gets accepted. 
% In particular 
the reward is stolen {\em before} a block is finalized into the blockchain. 


We note that all Type 2 schemes have an inherent problem that allows malicious actors to flood the network with a large number of valid but distinct solutions, thereby causing network partitions and instability. This causes the network to converge very slowly or result in several forks. Hence, we don't consider Type 2 schemes to be robust in reaching consensus, thereby making them impractical in the real world. We call this the {\em forking attack}. Strong Type 2 schemes are even more prone to this attack because there is no fear of detection (and penalization).

In this work, we break the non-outsourceability of all Type 1 and weak Type 2 schemes assuming that their platforms support
some minimal smart contract capability. The following table summarizes this. 

~\\
	\begin{tabular}{lllll}
		  Type     & Thief's Identity   & When Rewards Stolen       & Forking attack  \\\hline
		  1        & revealed              & after block acceptance   & no             \\
		  2 (weak)   & revealed           & before block acceptance  & yes            \\
		  2 (strong) & secret           & before block acceptance  & yes            
	\end{tabular}

% In this view, Ergo is a special instance of a non-outsourceable puzzle of~\cite{miller2015nonoutsourceable}, where the contention is not to generate a new message $m'$, that sends the reward to a different address (which is not possible in Ergo). Instead the goal is to steal the reward 720 blocks later, when it becomes spendable. 

\subsection{Execution Context in Smart Contracts}

To give understanding of how a smart contract can bypass non-outsourceability, we first explain what kind of data the contract
can access.

In Proof-of-Work currencies a block is split usually into sections, with a compact section called {\em header} which is
enough to verify Proof-of-Work puzzle solution and also to check integrity of other sections (such as block transactions).

Execution context is what available to a contract during execution. Considering UTXO-based cryptocurrencies, such as
Bitcoin and Ergo, we can think about following components of the execution context. In the first place, smart contract
 may have access to the UTXO it is locking (e.g. monetary value of the UTXO). In the second place, smart contract may
 have access to the spending transaction with its inputs and outputs. In the third place, smart contract may have access
 to block header data. For example, in Ergo last ten block headers and also parts of the next block header which could
 be known to the miner before starting mining of the new block do belong to the execution context. Finally, execution
 context may contain the full block with all its transactions. Please note, as execution context must be fit into
 random-access memory of commodity hardware, accessing full blockchain is not the realistic case. Table \ref{???}
 summarizing possible execution context components.


\begin{tabular}{llllllll}
	& Level & UTXO & Transaction & Header      & Block & Example \\ \hline
	& 1     & No  & No          & No  		   & No    & Bitcoin \\
	& 2     & Yes & Yes         & No 		   & No    & -- \\
	& 3     & Yes & Yes         & Yes 		   & No    & Ergo    \\
	& 4     & Yes & Yes         & Yes 		   & Yes   & --    \\
\end{tabular}
	
\section{Pooled Mining in Type 1 Puzzles}

% Ergo uses \powname as its underlying proof-of-work mechanism and Ergo's reward system can be considered as a type of PieceWork puzzle \snote{Check validity of this statement}.

% We first describe Type 1 puzzles in detail before describing our break in the next section.
In a nutshell, Type 1 puzzles use a combination of two techniques: (1) replacing the core hash function with a digital signature (i.e., using public-key cryptography) and (2) tying the public key to the rewards.

\subsection{Using Public-Key Cryptography}

The method requires a randomized signature scheme that is strongly unforgeable against adaptive chosen message attacks (s-UFCMA)) and outputs signatures uniformly spread over some range irrespective of how the signer behaves. Schnorr signature scheme is one such scheme.

A candidate block header is constructed using transactions as in Bitcoin along with a public key $p$. A valid block header is a candidate block header along with a signature $d$ that (1) verifies with this public key and (2) satisfies the difficulty constraints as in bitcoin (i.e., is less than a certain value). The difficulty parameter is automatically adjusted to ensure consistent time between solutions.

One real-world implementation of this concept is in \powname, the PoW algorithm of Ergo which uses a variation of Schnorr signatures as follows. The goal of a miner is to output $d$ such that $d < 2^{256}/\lambda$, where $\lambda$ is the difficulty parameter. The value $d$ is to be computed as follows. First compute $r = H(m\|n\|p\|w)$ where $m$ is the transactions digest, $n$ is a nonce, $p$ is a public key (an elliptic curve group element) and $w$ is an ephemeral public key that should never to be reused in two different blocks. Let $x$ be the corresponding private key of $w$. Compute $d = xr - s$, where $s$ is the private key corresponding to $p$.


% At this point we must distinguish between two types of reward mechanisms. The first is where the rewards are {\em created} at the time of mining, also termed as {\em post-mine}. The second is where the rewards are {\em unlocked} at the time of mining, but were created much earlier {\em pre-mine}.

% Using this terminology, we can say that an Ergo-like system does not prevent pools for post-mined rewards but can be made pool-resistant for pre-mined rewards, as discussed next.

\subsection{Tying Public-Key to Rewards}

The second technique in making a Type 1 pool-resistant scheme is to tie the rewards to the public key $p$ contained in the block solution. That is, the platform enforces that any mining rewards are protected by the statement {\em prove knowledge of secret key corresponding to the public key $p$ (from the block solution)}

Rather than enforcing this logic within the protocol, Ergo uses smart contracts to enforce it. In particular, this rule is enforced in a so called \textbf{Emission box}, a UTXO which contains all the ergs that will ever be emitted in rewards. The box is protected by a script that enforces certain conditions on how the rewards must be collected. In particular, it requires that a reward transaction has exactly two outputs, such that the first is another emission box containing the remaining ergs and the second is a box with the miners reward (initially 67.5 Ergs) protected using the script: {\em prove knowledge of the discrete logarithm (to some fixed base $g$) of group element $p$ AND height is greater than or equal to the box-creation height plus 720}.
This is possible because Ergo's (Level 3) context includes the block solution.  

The above approach ensures that the private key used for finding the block solution is also needed for spending the rewards. Consequently, anyone who finds a block also has the ability to spend those rewards. 
If we try to create any standard type of pool, we find that anyone having the ability to find a solution also has the ability to spend (i.e., steal) the reward. In fact, any standard pool must share the same private key among all participants, thereby making it impossible to determine the actual spender. This restriction also applies to decentralized schemes such as P2Pool and SmartPool because they both require the miner be able to use arbitrary public keys for receiving the reward

\subsection{Creating a Mining Pool}

We now describe an approach to construct a mining pool for any Type 1 scheme, provided that the underlying smart contract language allows access to Level 3 context (see Section~\ref{context}). Hence one way to mitigate our method would be to restrict the smart contract language to Level 2 or lower. Our concrete implementation uses Ergo as the underlying platform, which supports Level 3 context.

\textbf{Basic variant:} We first describe a basic version that is insecure, and thereby does not work in reality. We then create the full version by extending the basic version by patching this vulnerability.

The key observation is that in a valid share, the reward need not necessarily be sent directly to the pool's address. What is actually necessary is that an amount equivalent to the reward is sent to the pool's address. This simple observation allows us to create a pool with the following rules:
\begin{enumerate}
	\item Each miner can send the reward to his own public key $p$, whose secret key only he knows ({\em reward transaction}).
	\item The block must also have another transaction sending the same amount as the reward to the pool address ({\em pool transaction}).
\end{enumerate}

A valid share is a solution to a block with the above structure. A pool operator collects such shares and any funds thus received are distributed among the miners based on the number of shares they submitted. One drawback of this is that each miner must have an equivalent amount of ergs to cover the reward amount at any time, even though the reward become spendable only after 720 blocks. 
This means that in order to continue mining after a block is found, each miner must keep the reserved amount of at least 2 rewards (possibly more depending on the expected time to find a block).

 To overcome this drawback, a pool may provide incentives such as allowing the miner to keep a small fraction of the reward (example for the current reward of 67.5 ergs, the pool may require only 65 ergs to be sent to it). A pool transaction can pay to any pool defined address. For instance, it could be a P2SH address of \texttt{poolPubKey}. 


\textbf{The broadcast attack:} Let Alice be a miner with public key $alice$. If such a system is used in, say Bitcoin, then the system becomes insecure. Once the pool-paying transaction is publicized, anyone (not necessarily Alice) may broadcast it (possibly by using it as their own pool transaction). 

\textbf{Full variant:} The full protocol mitigates the above attack. This is possible because \langname allows us to use the block solution in the context, using which we can secure the pool transaction as follows. Instead of paying to the pool from an arbitrary box (or boxes), Alice will instead store these funds in a special box protected by the following script:
\begin{verbatim}
(minerPubKey == alice) || bob
\end{verbatim}
The first part ensures that when used to fund the pool output, the miner must be Alice. The second ensures that the coins are not stuck till Alice finds a block (if ever). Here \texttt{bob} is another public key owned by Alice.

Note that the above attack mitigation strategy is unique to Ergo and will not work in generic pool-resistant protocols described in~\cite{miller2015nonoutsourceable}. One may envisage a hiding strategy, where the pool transaction is not revealed in a share (only a commitment is revealed). The actual transaction is revealed only for claiming shares or if a block is found. However, this is also insecure as discussed below. First note that there are two types of broadcast attacks. The first is the ``extract from share'' attack discussed above. The second is the ``extract from orphaned block'' attack, where the transaction is extracted from a mined block that ends up getting orphaned. While the hiding strategy works for the first attack, it does not mitigate the second. 

\section{Pooled Mining with Type 2 Puzzles}
% \section{10 Blocks}

Type 2 puzzles can be considered an variation of Type 1 puzzle. Recall that a Type 1 puzzle comprises of two steps: (1) embedding a public key $p$ in the block header, whose private key is needed in generating the solution, and (2) tying the block rewards to $p$. In the vanilla (weak) Type 2 puzzle, Step 1 remains the same and Step 2 above is modified as follows. The block rewards are not directly tied to $p$ but instead to another public key $a$ certified by $p$. The logic is similar to that of Type 1 puzzles. A miner computes shares where he sends the rewards to the pool public key $a$ but if a real solution is found, he sends the rewards to his own public key $a'$. Thus, similar to Type 1 puzzles, if the pool shares the secret key with a miner, they it risks losing the rewards. 
In the basic Type 2 scheme, a pool can make it possible to identify stolen rewards by publicly fixing a watermark identifying its blocks in advance~\cite{miller2015nonoutsourceable}. A watermark in this context is something that is preserved even if the pool key $a$ is replaced by the miner key $a'$. A few examples are the certifying key $p$ or the half the bits of the nonce. The stronger variant of Type 2 puzzles replaces $a$ by a zero knowledge proof so that it is not possible to distinguish the cases when $a$ or some other $a'$ is present in the solution.  

We describe a collateralized smart contract which is working for both Type 1 and Type 2 scheme. For sake of brevity,
we describe a solution for Type 2 schemes only here. We remind that in such schemes a miner can produce~(with
non-negligible probability) an alternative block for the same PoW solution. Thus the miner can generate block shares
which the pool accepts, but in case of block with network difficulty generated, the miner is replacing it with another
block paying to the miner only. As noted in~\cite{miller2015nonoutsourceable}, the pool still can detect that the miner
run away by requiring for the block solution to have some watermark~(e.g. by splitting the nonce into two halfs and
requiring first half to contain certain bits).
However, if block solutions for some number $L$ of last block headers are available in the script execution context
then the scheme could be bypassed by the following contract. First, the miner is creating a coin which is locking
collateral to the following condition "payable to the pool's public key if one of the last L headers contains
the watermarked solution"~(we are skipping needed in practice deadline condition for withdrawing the collateral for
simlicity's sake here).
Then the miner simply gets away with the mined block, anyway, the pool will claim the collateral within $L$. The only
way for the miner to save the collateral is to generate $L$ blocks after one with the watermark, but this is unlikely
the case for pool user if $L$ is big enough. For example, in Ergo, 10~last block headers available in the execution
context, and chance to generate 11 blocks in a row is small~\cite{Nak08}.



\section{Conclusion}

Can a Level 2 smart contract platform be used to bypass non-outsourceability of Type 1 schemes?
How can we make it fully decentralized (as in SmartPool or P2Pool)?

\bibliographystyle{unsrt}
\bibliography{main}
\appendix


\end{document}
