\section{Autolykos Consensus Protocol}
\label{sec:autolykos}

% Почему выбрали PoW
% Известные проблемы PoW
% Детали Автоликуса

The core component of any blockchain system is its consensus protocol.
Despite extensive research of possible alternatives to original the Proof-of-Work (PoW) protocol,
it remains in demand due to simplicity, high security guarantees, and friendliness to light clients.
However, a decade of extensive testing revealed several problems of the original one-CPU-one-vote idea.

First known problem of PoW is that development of specialized hardware (ASIC) allowed
a small group of ASIC-equipped miners to solve PoW puzzles orders of magnitude faster and more efficiently
than everyone else. This problem can be solved with the help of memory-hard PoW schemes,
that reduce the disparity between the ASICs and commodity hardware. The most promising approach here
is to use asymmetric memory-hard PoW schemes that require significantly less memory
to verify a solution than to find it where proposed~\cite{biryukov2017equihash,ethHash}.

The second known threat to a PoW network decentralization is that even big miners trend to unite in
mining pools, leading to a situation when just a few pool operators (5 in Bitcoin, 2 in Ethereum
at the time of writing) controls more than 51\% of computational power.
Although the problem has already been discussed in the community, no practical solutions were
implementer before \Ergo{}.


Ergo PoW protocol --- Autolykos --- is the first consensus protocol, that is both memory-hard
and pool resistant~\cite{Ergopow}.
Autolykos is based on one list $k$-sum problem: miner should find
$k=32$ elements from the pre-defined list $R$ of size $N=2^{26}$~(which have a size of 2 Gb),
such that $\sum_{j \in J} r_{j} - sk = d$ is in the interval $\{-b,\dots,0,\dots,b\mod q\}$.
Elements of list $R$ are obtained as a result of one-way computation from index $i$,
two miner public keys $pk,w$ and hash of block header $m$ as $r_i=H(i||M||pk||m||w)$,
where $M$ is a static big message that is used to make hash calculation slower.
In addition, we require a set of element indexes $J$ to be obtained
by one-way pseudo-random function $genIndexes$, that prevents possible solutions
search optimizations.

Thus we assume that the only option for a miner is to use the simple brute-force algorithm~\ref{alg:prove} to
create a valid block.

\begin{algorithm}[H]
    \caption{Block mining}
    \label{alg:prove}
    \begin{algorithmic}[1]
        \State \textbf{Input}: latest block header hahs $m$, key pair $pk=g^{sk}$
        \State Generate randomly a new key pair $w=g^x$
        \State Pre-calculate list $R$ where $r_i=H(j||M||pk||m||w)$
        \While{$true$}
        \LetRnd{$nonce$}{$\mathsf{rand}$}
        \Let{$J$}{$genIndexes(m||nonce)$}
        \Let{$d$}{$\sum_{j \in J}{r_j} \cdot x - sk \mod q$}
        \If{$d < b$}
        \State \Return $(m,pk,w,nonce,d)$
        \EndIf
        \EndWhile
    \end{algorithmic}
\end{algorithm}

Note that although the mining process utilizes private keys, the solution itself
only contains public keys. Solution verification can be performed by Alg.~\ref{alg:verify}.

\begin{algorithm}[H]
    \caption{Solution verification}
    \label{alg:verify}
    \begin{algorithmic}[1]
        \State \textbf{Input}: $m,pk,w,nonce,d$
        \State require $d < b$
        \State require $pk,w\in \mathbb{G}$ and $pk,w \ne e$
        \Let{$J$}{$genIndexes(m||nonce)$}
        \Let{$f$}{$\sum_{j \in J} H(j||M||pk||m||w)$}
        \State require $w^f = g^dpk$
    \end{algorithmic}
\end{algorithm}

Target parameter $b$ is adjusted to the current network hash rate via difficulty adjustment
algorithm~\cite{meshkov2017short}, that is trying to predict an upcoming 1024 block length
epoch hash rate based on data from the previous 8 epochs.
Full technical specification of Autolykos may be found at~\cite{Ergopow}.