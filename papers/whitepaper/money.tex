\section{Contractual Money}
    \label{sec:contractual}

    %   пишет Саша

    %   ценность нашего токена, и филосовские размышления о данном типе экономики
    %   практические удобные и эффективные контракты для денег
    %   Описать про UTXO модель, почему мы ее выбрали
    %   Скрипт - доступ к стейту, доступ к блокчейну, цепочки (тут можно сослаться на Эфир, ибо там написано что в UTXO это невозможно), сигма протоколы
    %   token system - токены на базовом уровне, сильно упрощают протоколы вида "token threshold", позволяют разграничить потоки
    %   ? Анонимность и пример контракта миксинга
    %   Примеры 1-2 контракта, который иллюстрируют несколько основных преимуществ эрго


\subsection{Ergo Token Value}
 \label{sec:ergo-value}

 In this section we are going to provide some reflections on nature of the native Ergo token. For starters, we note that
 any currency is about three main functions: medium of exchange, unit of account, and store of value.

 Bitcoin, being historically the first digital scarce asset, is a perfect as store-of-value. It is even better than
 gold under certain assumptions~(such as SHA-256 hash function not being broken, and majority of miners are not willing
 to destroy the Bitcoin), as emission is limited and known in advance. However, being perfect store-of-value also means
 to be not so good as medium-of-exchange. In particular, if one knows that Bitcoin is indeed the best tool to store
 value in the long term, he would use fiat whenever possible in order to collect more bitcoins.

 On the other hand, Ethereum is not just a currency, but an utility token used to pay for computations over the
 "decentralized world computer" (or "fully replicated programmable calculator"). However, Ethereum is not good as
 store-of-value, as emission in endless, and, historically, can be changed easily by the community core along with
 critical system assumptions.

 Ergo combines best from these two top blockchains. Emission is predefined and limited, more, it will be finished within
 just 10 years. The system assumptions are set in stone with precisely defined {\em social contract}. \knote{link}. Also,
 Ergo is a utility token used to pay for storage rent. This storage rent is making system more stable. Last, Ergo is
 suitable to build monetary systems on top of it with properties different from Ergo native token itself. However,
 participating in such systems would require to use Ergo native token as well in order to pay storage rent.

\subsection{UTXO vs Accounts}
 \label{sec:utxo}

 To check a new transaction, a cryptocurrency client is not using the ledger (all the transactions happened before the
 transaction), rather, it is using ledger state snapshot got from the history. In Bitcoin Core reference implementation,
 this snapshot is about active one-time coins, and a transaction is destroying some coins and also creating new ones.
 In Ethereum, the snapshot is about long-living accounts, where an account is controlled whether by a human or
 executable code; a transaction then is modifying monetary balance and internal memory of some accounts. Also, the
 representation of the snapshot in Ethereum~(unlike Bitcoin) is fixed by the protocol, as authenticating digest of the
 snapshot is written into a block header (thus, in order to have full security guarantees, a client needs to build
 the same snapshot as a miner).

 Ergo is representing the snapshot in form of one-time coins, like Bitcoin. The difference is, in addition to monetary
 value and protecting script, an Ergo coin contains additinal registers with arbitrary data, thus we use term {\em box}
 instead of {\em coin}. Also, like in Ethereum, the ledger snapshot representation~(in form of boxes not destroyed by
 previous transactions) is fixed by the Ergo protocol.

\subsection{The Ergo As The Platform}
 \label{sec:platform}

 In our opinion, 99\% of public blockchain use-cases are about financial applications, even in the presence of a
 general-purpose decentralized world computer, such as Ethefeum Classic. For example, even if an oracle is writing
 non-financial data into a blockchain (such as temperature), this data is usually to be written to be used in a financial
 contract. Another trivial observation we have made, is that many applications are using digital tokens with mechanics
 different from a native token of a blockchain system~(especially application built on top of Ethereum).

 Thus Ergo offers for an application developer in-built tokens~(with minimal functionality per se, in comparison with
 Waves or Nxt), and domain-specific language for box guarding condition which is powerful enough to define rich
 financial applications. Thus Ergo applications are defined in terms of guarding scripts built into boxes also containing
 data possibly involved into execution. We coin the term {\em contractual money} for Ergs and secondary tokens which
 usage is bounded by a contract. In narrow sense, we can distinguish Ergs in existence as ones which could easily
 change their contracts from Ergs which are bounded by contracts in the sense that a box with contractual Ergs is
 demanding from a spending transaction to create boxes with some properties. We will refer to the former as to ordinary
 (or cleared, or free) Ergs, and to the latter as to the contractual Ergs. Similarly, we can define contractual tokens.

 For example, if a box is protected just by a public key~(so providing a signature against a spending transaction is
 enough in order to destroy the box), a public key owner may create an arbitrary box replacing the one being protected
 by the public key, thus the Ergs within the box are free to change the contract. In contrast, imagine a box "B" which
 is protected by combination of a public key and also condition which demands a spending transaction to create an output
 box which guarding script hash is equal to "rBMUEMuPQUx3GzgFZSsHmLMBouLabNZ4HcERm4N" (in Base58 encoding), and Ergs
 value of the output should equal to the value of the original box. In this case box value is bounded by the contract,
 thus Ergs in the box are contractual Ergs.

\subsection{Difference From Bitcoin}

 While in Bitcoin a transaction output~(a digital coin) is protected by a program in stack-based language, in Ergo a
 box is protected by a logic formula which combines predicates over a context and cryptographic statements provable
 via zero-knowledge protocols with AND, OR, and k-out-of-n connectives. The formula is represented as a typed direct
 acyclic graph, which serialized form is written in a box. To destroy a box, a spending transaction needs to provide
 arguments, including zero-knowledge proofs, which are enough to satisfy the formula.

 However, in most cases a developer is unlikely to develop box contracts in terms of graphs. Instead, he would likely
 using a high-level language, and we provide one called ErgoScript. Writing scripts in this language is easy, for
 example, for a one-out-of-two signature, protecting script would be ${pk_1 \&\& pk_2}$, which means "prove knowledge of
 a secret key corresponding to the public key $pk_1$, or knowledge of a secret key corresponding to $pk_2$". We have
 two separate documents which are helping to develop contracts with ErgoScript, the "ErgoScript Tutorial"~\cite{}
 and "Advanced ErgoScript Tutorial"~\cite{}. Thus below we are not going to dive into developing contracts with
 ErgoScript, rather, we are going to provide a couple of motivation examples.

\subsection{Data Inputs}
 \label{sec:data-inputs}

 A box could be not only destroyed by a transaction, but is also could be only read, in the latter case we refer to the
 box as to {\em data input} of the transaction. Thus a transaction is getting two box sets as its arguments, inputs and
 data inputs, and produces a box set named {\em outputs}. Data inputs are useful for oracle applications and interacting
 contracts.

\subsection{Custom tokens}
 \label{sec:custom tokens}

 A transaction can carry many tokens, if only estimated complexity for processing them is not exceeding a limit. A
 transaction is also able to issue a token, but only one, and with a unique~(and cryptographically strong against
 finding a collision) identifier, which is equal to identifier of a first~(spendable) input box of the transaction.
 The amount of the tokens issued could be any number within the [1, 9223372036854775807] range. For the tokens, the weak
 preservation rule is defined, which is demanding total amount for a token in transaction outputs should be no more
 than total amount for the token in transaction inputs~(thus some amount of token could be burnt). In contrast, for Ergs
 a preservation rule is strong, thus total Ergs amount for inputs should be equal to total Ergs amount for outputs.

\subsection{An Oracle Example}
 \label{sec:platform}

 Equipped with custom tokens and data inputs, we can develop a simple oracle example, also showing on the way some
 design patterns for Ergo contracts. In the example, Alice and Bob are putting money into a box, which is spendable by
 Alice if temperature is more than 15 degrees, and is spendable by Bob otherwise. To deliver temperature into the
 blockchain a trusted oracle is needed.

 In opposite to Ethereum with its long-lived accounts, where trusted oracle identifier is usually known in advance,
 delivering data with one-time boxes is more tricky. For starters, a box which is protected by an oracle's key could
 not be trusted, as anyone can create such a box. It is possible to include a signed data into a box, and check the
 signature in the contract using the data, we have such an example, but this example is quite involved. With custom
 tokens, however, a solution is pretty simple.

 In the first place, a token identifying the oracle should be issued. In the simplest case, amount for the token could
 be equal to one. Then the oracle is creating a box which contains the token and also temperature, for example, in the
 register number four~($R4$). In order to update temperature, an oracle is destroying the outpdate box and creating a
 new one with updated temperature.

 Then, like in Ethereum, Alice and Bob usually know oracle's token identifier in advance. With this knowledge, they
 can jointly create a box which requires first data input (which is read-only) to contain the oracle's token. The
 contract is extracting temperature from the data input and decides who is getting the payout. The code is as simple as


 \begin{algorithm}[H]
    \caption{Oracle Contract Example}
    \label{alg:oracle}
    \begin{algorithmic}[1]
        \State val dataInput = CONTEXT.dataInputs(0)
        \State val inReg = dataInput.R4[Long].get
        \State val inToken = dataInput.tokens(0).\_1 == tokenId
        \State val okContractLogic = (inReg $>$ 15L \&\& pkA) $||$ (inReg $<=$ 15L \&\& pkB)
        \State inToken \&\& okContractLogic
    \end{algorithmic}
 \end{algorithm}

\subsection{A Mixing Example}
 \label{sec:platform}

 Privacy is important for a digital currency, but implementing it in a protocol could be costly or require a trusted
 setup. Thus we are looking for ways to do coin mixing via cheap enough applications. As a first step towards that, we
 offer an application for non-interactive coin mixing, which is working in the following case:
 \begin{enumerate}
    \item{} Alice creates a box which demands any Bob's coin to satisfy certain conditions in order to be mixed with
    the coin of Alice. After that, Alice only listens to the blockchain, no any interaction with Bob is needed.
    \item{} Bob is creating a box and then a spending transaction which has boxes of Alice and Bob as inputs,
     and creates two outputs with the same script, but both Alice and Bob may spend only one box out of the two.
     An external observer can coin spent by whom, as output boxes are indistinguishable.
 \end{enumerate}

 For simplicity, we are not considering fees in the example. The idea of mixing is similar to non-interactive
 Diffie-Hellman key exchange. First, Alice creates a secret value $x$ and publishing a corresponding public value
 $gX = g^x$. She demands 

 \begin{algorithm}[H]
    \caption{Alice's Input Script}
    \label{alg:oracle}
    \begin{algorithmic}[1]
        \State val c1 = OUTPUTS(0).R4[GroupElement].get
        \State val c2 = OUTPUTS(0).R5[GroupElement].get
        \State
        \State OUTPUTS.size == 2 \&\&
        \State OUTPUTS(0).value == SELF.value \&\&
        \State OUTPUTS(1).value == SELF.value \&\&
        \State blake2b256(OUTPUTS(0).propositionBytes) == fullMixScriptHash \&\&
        \State blake2b256(OUTPUTS(1).propositionBytes) == fullMixScriptHash \&\&
        \State OUTPUTS(1).R4[GroupElement].get == c2 \&\&
        \State OUTPUTS(1).R5[GroupElement].get == c1 \&\& \{
        \State\hspace{\algorithmicindent}  proveDHTuple(g, gX, c1, c2) $||$
        \State\hspace{\algorithmicindent}  proveDHTuple(g, gX, c2, c1)
        \State \}
    \end{algorithmic}
 \end{algorithm}

 \begin{algorithm}[H]
    \caption{Mixing Transaction Output Script}
    \label{alg:oracle}
    \begin{algorithmic}[1]
        \State val c1 = SELF.R4[GroupElement].get
        \State val c2 = SELF.R5[GroupElement].get
        \State proveDlog(c2) $||$            // either c2 is $g^y$
        \State proveDHTuple(g, c1, gX, c2) // or c2 is $u^y = g^{x \cdot y}$
    \end{algorithmic}
 \end{algorithm}


\subsection{The Local Exchange Trading System}
 \label{sec:platform}

 Here we briefly overview a local exchange trading system implementation. In such system, a member of a community may
 issue community currency via personal debt. For example, if Alice with zero balance is buying something for 5
 community tokens from Bob, which balance is about zero as well, her balance after the trade would be -5 tokens, and
 Bob's balance would be 5 tokens. Then Bob could buy something for 5 tokens, for example, from Carol. Usually, in such
 systems there is a limit for negative balance.

 As digital community could be vulnerable to sybil attacks, thus some mechanism is needed in order to prevent creation
 of sybils creating debts. We consider two solutions, namely, a committee of trusted managers approving new members of
 the community, or securitуy deposits made in Ergs. For simplicity, we consider the approach with the committee here.

 This example is about two interacting contracts then. In the first place, a management script is about maintaining a
 community members list, and a new member could be added if management condition (e.g. threshold signature from a
 committee) satisfied. In the second

\subsection{More Examples}

 We have more examples of Ergo applications.
